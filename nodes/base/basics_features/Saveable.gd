"""
	@author: Obrymec
	@company: CodiTheck
	@famework: Godot Mega Assets
	@compatibility: Godot 3.x.x
	@platform: ANDROID || IOS || MACOSX || UWP || HTML5 || WINDOWS || LINUX
	@license: GNU 3.0
	@source: www.google.com
	@language: GDscript
	@dimension: 2D || 3D
	@type: Saveable
	@version: 1.0.0
	@created: 2021-06-15
	@updated: 2021-06-28
"""
################################################################################### [Main class] #############################################################################
"""@Description: A class that represents some basics functionalities common to all destructibles saveables modules of the Godot MegaAssets framework."""
tool class_name Saveable, "saveable.svg" extends Destructible;

################################################################################### [Attributes] #############################################################################
# Contains all basics saveable properties of a Godot Mega Assets module.
func _basics_saveable_module_properties () -> void:
	# Contains the module title category.
	self.bind_prop (Dictionary ({title = "Saveable", index = 0}));
	"""
		@Description: Which data manager do you want choose you ? It is according to the latter that the data of the module in question will be loaded and
			or saved. This option is only available on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "DataManager", value = 0, type = TYPE_INT, dropdown = GameDataManager.keys (),
		attach = PoolStringArray (["DataManager", "Checkpoint", "Section", "GlobalKey", "SaveData", "LoadData"]),
		changed = {callback = "module_values_changed ()", params = Array ([null, null])}, min = 0, max = 2
	}));
	"""
		@Description: On which checkpoint, the data of the module will be saved and/or loaded ? Note that the precision of the latter is not mandatory. In this
			case, the active savepoint on the "SaveLoadFx" module will be taken for target. (Only use this field if the chosen data manager targets the module
			"SaveLoadFx"). This option is only available on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "Checkpoint", value = String (''), type = TYPE_STRING, attach = "Checkpoint", visible = false,
		changed = {callback = "module_values_changed ()", params = Array ([null, null])}, showif = "DataManager == 1"
	}));
	"""
		@Description: On which configuration section, the data of the module will be saved and/or loaded ? Note that the accuracy of the latter is highly obligatory.
			(Only use this field if the chosen data manager targets the module "SettingsFx"). By default, a configuration section name is automatically generated
			by the module. You can change it to whatever you want. This option is not available only on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "Section", value = ((self.name + "Section") if !self.name.empty () else (self.get_class () + "Section")),
		type = TYPE_STRING, changed = {callback = "module_values_changed ()", params = Array ([null, null])}, attach = "Section", showif = "DataManager == 2",
		require = {statement = "AutoCompile && not Section", actions = {message = "This property cannot be empty.", type = Message.ERROR}}, visible = false
	}));
	"""
		@Description: Defines the global identifier to be used during data backups and uploads. By default, a key is generated by the module. You have the
			possibility of changing it to what you want. The role of this attribute is to allow updating data manager with data from multiple instances of
			the same module independently. Note that filling in this field is strongly required. This option is only available on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "GlobalKey", value = (self.name if !self.name.empty () else self.get_class ()), type = TYPE_STRING,
		changed = {callback = "module_values_changed ()", params = Array ([null, null])}, attach = "GlobalKey", visible = false, showif = "DataManager > 0",
		require = {statement = "AutoCompile && !GlobalKey", actions = {message = "This property cannot be empty.", type = Message.ERROR}}
	}));
	"""
		@Description: Controls the saving of data within a module. In other words, do you want to automatically save module data all times game data manager
			will be saved ? This option is only available on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "SaveData", value = false, type = TYPE_BOOL, attach = "SaveData", showif = "DataManager > 0",
		changed = {callback = "module_values_changed ()", params = Array ([null, null])}, visible = false
	}));
	"""
		@Description: Controls the loading of data within a module. In other words, do you want to automatically load the data to the starting the game ?
			This option is only available on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "LoadData", value = false, type = TYPE_BOOL, attach = "LoadData", showif = "DataManager > 0",
		changed = {callback = "module_values_changed ()", params = Array ([null, null])}, visible = false
	}));
	# Attaches "EventsBindings", "GlobalKey" and "Section" properties to "AutoCompile" property.
	self.override_prop (Dictionary ({attach = PoolStringArray (["AutoCompile", "EventsBindings", "GlobalKey", "Section"])}), "AutoCompile");

#################################################################################### [Signals] ###############################################################################
"""@Description: Trigger before updating manager of different game data."""
signal before_update_data (node);
"""@Description: Trigger after updating the manager of the various game data."""
signal after_update_data (node);
"""@Description: Trigger before saving module data."""
signal before_save_data (node);
"""@Description: Trigger after saving module data."""
signal after_save_data (node);
"""@Description: Trigger before loading module data."""
signal before_load_data (node);
"""@Description: Trigger after loading module data."""
signal after_load_data (node);
"""@Description: Trigger before destroying module data."""
signal before_destroy_data (node);
"""@Description: Trigger after destroying module data."""
signal after_destroy_data (node);

############################################################################## [Particulars variables] #######################################################################
# Contains all fixed "AutoCompile" mdule property listeners for this class.
var _auto_compile_listeners: Array = Array (["AutoCompile", "GlobalKey", "Section", "EventsBindings"]) setget _unsetable_var_error;
# Contains all fixed "DataManager" mdule property listeners for this class.
var _data_manager_listeners: Array = Array (["DataManager", "Checkpoint", "Section", "GlobalKey", "SaveData", "LoadData"]) setget _unsetable_var_error;

############################################################################### [Properties manager] #########################################################################
# Unsetable module variables.
func _unsetable_var_error (_new_value) -> void: self.output ("Can't change value of this variable.", Message.ERROR, self);

############################################################################## [Logic and main tasks] ########################################################################
# This method is called on game initialization and before all nodes instanciation.
func _init (): self._basics_saveable_module_properties ();

############################################################################### [Availables features] ########################################################################
"""@Description: Returns the version a module."""
static func get_version () -> String: return "1.0.0";

"""@Description: Return all origins of a module."""
static func get_origin_name () -> String: return "MegaAssets.Module.Destructible.Saveable";

"""@Description: Is the base class for all modules is serializable ?"""
static func is_saveable () -> bool: return true;

"""@Description: Returns a module class type."""
func get_class (): return "Saveable";

"""@Description: Destroys the given properties from his name from "__props__" dictionary."""
func destroy_props (source, delay: float = 0.0) -> void:
	# Destroys the passed property(es) and listen a certain properties.
	.destroy_props (source, delay);
	# "AutoCompile" module property exists.
	if self.get_prop ("AutoCompile") is bool:
		# "GlobalKey" property has been destroyed.
		if not self.get_prop ("GlobalKey") is String: _auto_compile_listeners.erase ("GlobalKey");
		# "Section" property has been destroyed.
		if not self.get_prop ("Section") is String: _auto_compile_listeners.erase ("Section");
		# "EventsBindings" property has been destroyed.
		if not self.get_prop ("EventsBindings") is Array: _auto_compile_listeners.erase ("EventsBindings");
		# Overrides "attach" key of "AutoCompile" module property.
		self.override_prop (Dictionary ({attach = self._auto_compile_listeners}), "AutoCompile");
	# "DataManager" module property exists.
	if self.get_prop ("DataManager") is int:
		# "GlobalKey" property has been destroyed.
		if not self.get_prop ("GlobalKey") is String: _data_manager_listeners.erase ("GlobalKey");
		# "Section" property has been destroyed.
		if not self.get_prop ("Section") is String: _data_manager_listeners.erase ("Section");
		# "Checkpoint" property has been destroyed.
		if not self.get_prop ("Checkpoint") is String: _data_manager_listeners.erase ("Checkpoint");
		# "LoadData" property has been destroyed.
		if not self.get_prop ("LoadData") is bool: _data_manager_listeners.erase ("LoadData");
		# "SaveData" property has been destroyed.
		if not self.get_prop ("SaveData") is bool: _data_manager_listeners.erase ("SaveData");
		# Overrides "attach" key of "DataManager" module property.
		self.override_prop (Dictionary ({attach = self._data_manager_listeners}), "DataManager");
