"""
	@author: Obrymec
	@company: CodiTheck
	@famework: Godot Mega Assets
	@compatibility: Godot 3.x.x
	@platform: ANDROID || IOS || MACOSX || UWP || HTML5 || WINDOWS || LINUX
	@license: MIT
	@source: https://godot-mega-assets.herokuapp.com/docs/bases/recordable
	@language: GDscript
	@dimension: 2D || 3D
	@type: Recordable
	@version: 0.2.3
	@created: 2021-06-16
	@updated: 2021-08-31
"""
################################################################################### [Main class] #############################################################################
"""@Description: A class that represents some basics functionalities common to all indestructibles saveables modules of the Godot MegaAssets framework."""
tool class_name Recordable, "saveable.svg" extends Indestructible;

################################################################################### [Attributes] #############################################################################
# Contains all basics saveable properties of a Godot Mega Assets module.
func _basics_saveable_module_properties () -> void:
	# Contains the module title category.
	self.bind_prop (Dictionary ({title = "Saveable", index = 0}));
	"""
		@Description: Which data manager do you want choose you ? It is according to the latter that the data of the module in question will be loaded and
			or saved. This option is only available on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "DataManager", value = 0, type = TYPE_INT, dropdown = GameDataManager.keys (),
		attach = PoolStringArray (["DataManager", "Checkpoint", "Section", "GlobalKey", "SaveData", "LoadData"]),
		changed = Dictionary ({callback = "module_values_changed ()", params = Array ([null, null])}), min = 0, max = 2, require = Array ([
			{statement = "DataManager == 0", actions = Array ([Dictionary ({slot = "SaveData", value = false}), Dictionary ({slot = "LoadData", value = false})])},
			Dictionary ({statement = "_module_state () and DataManager > 0", actions = Dictionary ({slot = "_fix_data_manager_events ()", params = true})})
		])
	}));
	"""
		@Description: On which checkpoint, the data of the module will be saved and/or loaded ? Note that the precision of the latter is not mandatory. In this
			case, the active savepoint on the "SaveLoadFx" module will be taken for target. (Only use this field if the chosen data manager targets the module
			"SaveLoadFx"). This option is only available on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "Checkpoint", value = String (''), type = TYPE_STRING, attach = "Checkpoint", visible = false,
		changed = Dictionary ({callback = "module_values_changed ()", params = Array ([null, null])}), showif = "DataManager == 1"
	}));
	"""
		@Description: On which configuration section, the data of the module will be saved and/or loaded ? Note that the accuracy of the latter is highly obligatory.
			(Only use this field if the chosen data manager targets the module "SettingsFx"). By default, a configuration section name is automatically generated
			by the module. You can change it to whatever you want. This option is not available only on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "Section", value = ((self.name + "Section") if !self.name.empty () else (self.get_class () + "Section")),
		type = TYPE_STRING, changed = Dictionary ({callback = "module_values_changed ()", params = Array ([null, null])}), attach = "Section",
		require = Dictionary ({statement = "AutoCompile && not Section", actions = Dictionary ({message = "This property cannot be empty.", type = Message.ERROR})}),
		visible = false, showif = "DataManager == 2"
	}));
	"""
		@Description: Defines the global identifier to be used during data backups and uploads. By default, a key is generated by the module. You have the
			possibility of changing it to what you want. The role of this attribute is to allow updating data manager with data from multiple instances of
			the same module independently. Note that filling in this field is strongly required. This option is only available on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "GlobalKey", value = (self.name if !self.name.empty () else self.get_class ()), type = TYPE_STRING, visible = false,
		changed = Dictionary ({callback = "module_values_changed ()", params = Array ([null, null])}), attach = "GlobalKey", showif = "DataManager > 0",
		require = Dictionary ({statement = "AutoCompile && !GlobalKey", actions = Dictionary ({message = "This property cannot be empty.", type = Message.ERROR})})
	}));
	"""
		@Description: Controls the saving of data within a module. In other words, do you want to automatically save module data all times game data manager
			will be saved ? This option is only available on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "SaveData", value = false, type = TYPE_BOOL, attach = "SaveData", showif = "DataManager > 0",
		changed = Dictionary ({callback = "module_values_changed ()", params = Array ([null, null])}), visible = false, require = Dictionary ({
			statement = "AutoCompile && SaveData && DataManager == 0", actions = Dictionary ({slot = "SaveData", value = false,
				message = "This feature can't be enabled if no data manager has been specified.", type = Message.WARNING
			})
		})
	}));
	"""
		@Description: Controls the loading of data within a module. In other words, do you want to automatically load the data to the starting the game ?
			This option is only available on saveable modules.
	"""
	self.bind_prop (Dictionary ({source = "LoadData", value = false, type = TYPE_BOOL, attach = "LoadData", showif = "DataManager > 0",
		changed = Dictionary ({callback = "module_values_changed ()", params = Array ([null, null])}), visible = false, require = Dictionary ({
			statement = "AutoCompile && LoadData && DataManager == 0", actions = Dictionary ({slot = "LoadData", value = false,
				message = "This feature can't be enabled if no data manager has been specified.", type = Message.WARNING
			})
		})
	}));
	# Attaches "GlobalKey" and "Section" properties to "AutoCompile" property.
	self.override_prop (Dictionary ({attach = PoolStringArray (["AutoCompile", "GlobalKey", "Section"])}), "AutoCompile");

#################################################################################### [Signals] ###############################################################################
"""@Description: Trigger before updating manager of different game data."""
signal before_update_data ();
"""@Description: Trigger after updating the manager of the various game data."""
signal after_update_data ();
"""@Description: Trigger before saving module data."""
signal before_save_data ();
"""@Description: Trigger after saving module data."""
signal after_save_data ();
"""@Description: Trigger before loading module data."""
signal before_load_data ();
"""@Description: Trigger after loading module data."""
signal after_load_data ();
"""@Description: Trigger before destroying module data."""
signal before_destroy_data ();
"""@Description: Trigger after destroying module data."""
signal after_destroy_data ();

############################################################################## [Particulars variables] #######################################################################
# Contains all fixed "AutoCompile" mdule property listeners for this class.
var _auto_compile_listeners: Array = Array (["AutoCompile", "GlobalKey", "Section"]) setget _unsetable_var_error;
# Contains all fixed "DataManager" mdule property listeners for this class.
var _data_manager_listeners: Array = Array (["DataManager", "Checkpoint", "Section", "GlobalKey", "SaveData", "LoadData"]) setget _unsetable_var_error;
# Contains the target game data manager reference.
var _data_manager = null setget _unsetable_var_error;

############################################################################### [Properties manager] #########################################################################
# Unsetable module variables.
func _unsetable_var_error (_new_value) -> void: self.output ("Can't change value of this variable.", Message.ERROR, self);

# Returns the module state (ON/OFF).
func _module_state (): return self.is_unlock ();

############################################################################## [Logic and main tasks] ########################################################################
# This method is called on game initialization and before all nodes instanciation.
func _init (): self._basics_saveable_module_properties ();

# Called before ready method run.
func _enter_tree ():
	# The module is now out of reach of scene changes.
	if self.get_parent ().name == "DontDestroyOnLoad":
		# Connects this module reference to "enabled" signal.
		if !self.is_connected ("enabled", self, "_on_module_enabled") && self.connect ("enabled", self, "_on_module_enabled") != OK: pass;
		# The module is enabled.
		if self.is_unlock ():
			# Fix the target game data manager events.
			self._fix_data_manager_events (self.get_prop ("DataManager") > GameDataManager.NONE && !self.get_prop ("LoadData"));
			# Loads module data from the target data manager.
			if self.get_prop ("LoadData") and self._check_data_manager_state (): self._load_module_data ();

# Fix the target data manager events.
func _fix_data_manager_events (warnings: bool) -> void:
	# Fix the target game data manager events.
	if !Engine.editor_hint and self._check_data_manager (false, warnings) is bool and self._data_manager != null:
		# Checks whether this module is already connected to "after_load" event of the target game data manager.
		if !self._data_manager.is_connected ("after_load", self, "_dynamic_load_data"):
			# Connects this module reference to "after_load" signal of the target game data manager.
			if self._data_manager.connect ("after_load", self, "_dynamic_load_data") != OK: pass;
		# Checks whether this module is already connected to "before_save" event of the target game data manager.
		if !self._data_manager.is_connected ("before_save", self, "_dynamic_save_data"):
			# Connects this module reference to "before_save" signal of the target game data manager.
			if self._data_manager.connect ("before_save", self, "_dynamic_save_data") != OK: pass;

# Checks the given data manager and returns his reference or informations.
func _check_data_manager (other_components: bool, warnings: bool):
	# Contains the selected data manager from the module.
	var data_manager: int = self.get_prop ("DataManager");
	# Checks the passed game data manager.
	if data_manager > GameDataManager.NONE:
		# Getting the target game data manager reference.
		_data_manager = self.get_data_manager (self) if data_manager == GameDataManager.GAME_SAVES else self.get_settings_manager (self);
		# Checks whether a game data manager has been found.
		if self._data_manager is SaveLoadFx:
			# Should us return additionals informations ?
			if other_components:
				# Gets the module checkpoint/section value.
				var container = self.get_prop ("Checkpoint") if data_manager == GameDataManager.GAME_SAVES else self.get_prop ("Section");
				# Corrects the module checkpoint/section value and converts it into string format for other treatments.
				container = container if !container.empty () else null; var container_str: String = container if container != null else String ('');
				# Returns all informations about the target game data manager.
				return Array ([container, container_str, (self.get_prop ("GlobalKey").replace (' ', '') + "$-$")]);
			# Otherwise.
			else: return true;
		# No data manager found.
		else: if warnings: self.output ("The target game data manager isn't defined.", Message.WARNING, self);
	# Warning message.
	else: if warnings: self.output ("No data manager has been specified.", Message.WARNING, self); return null;

# Runs "UPDATE", "LOAD" and "STATE" actions from the module property(ies).
func _module_data_crud (action: int):
	# Contains the target game data manager informations.
	var manager_data = self._check_data_manager (true, true);
	# No warnings detected.
	if manager_data is Array:
		# Updates the game data manager with the given module property(ies) value(s).
		for prop in self.__props__:
			# Is it a saveable property ?
			if self.__props__ [prop].saveable:
				# Generates the real property id.
				var prop_id: String = (manager_data [2] + (prop + ".prop").get_file ().split ('.') [0]);
				# For "UPDATE" action.
				if action <= 0: self._data_manager.set_data (prop_id, self.__props__ [prop].value, manager_data [1]);
				# For "LOAD" action.
				elif action == 1: self.__props__ [prop].value = self._data_manager.get_data (prop_id, self.__props__ [prop].value, manager_data [1]);
				# For "STATE" action.
				else:
					# The current property id is it defined on the game data manager ?
					if self._data_manager.has_keys (prop_id, manager_data [0]):
						# Gets the current property value.
						var value = self._data_manager.get_data (prop_id, null, manager_data [1]);
						# Checks the loaded property value.
						if typeof (value) == typeof (self.__props__ [prop].value) and hash (value) == hash (self.__props__ [prop].value): pass; else: return false;
					# Otherwise.
					else: return false;
		# All passed properties are already saved into the target game data manager.
		return true;
	# Otherwise.
	else: return false;

# Checks the target data manager run constraints.
func _check_data_manager_state () -> bool:
	# No data manger specified.
	if self.get_prop ("DataManager") <= GameDataManager.NONE: return false;
	# For any found data mnager.
	elif self._data_manager is SaveLoadFx:
		# The data manager isn't enabled.
		if !self._data_manager.is_unlock (): return false;
		# Auto load game data is disable on the target data mnager.
		elif !self._data_manager.get_prop ("LoadAllData") && !Array (self._data_manager.get_prop ("TargetScenes")).has (self.get_tree ().current_scene.name): return false;
		# The data manager is activate.
		elif not self.is_game_initialised (): return false; else: return true;
	# For other cases.
	else: return false;

# Saves module data into the target game data manager.
func _save_module_data ():
	# Updates the given game data manager with the module property(ies) value(s).
	self._update_data_manager (); self.emit_signal ("before_save_data");
	# For game saves and configurations manager. Then thrown "after_save_data" event.
	if self._data_manager is SaveLoadFx: self._data_manager.save_game_data (); else: self._data_manager.save_game_configs (); self.emit_signal ("after_save_data");

# Loads the module data dynamically.
func _dynamic_load_data (_datum_count) -> void:
	# The module is it enabled ?
	if self.is_unlock ():
		# The game is not fully initialized. Should us load module on any loading detection ?
		if not self.is_game_initialised (): yield (self.get_tree (), "idle_frame"); if self.get_prop ("LoadData"): self._load_module_data ();

# Updates the target data manager with the module property(ies) value(s).
func _update_data_manager ():
	# Thrown "before_update_data" and "after_update_data" events.
	self.emit_signal ("before_update_data"); self._module_data_crud (0); self.emit_signal ("after_update_data");

# Loads all module data from the target game data manager.
func _load_module_data ():
	# Thrown "before_load_data" and "after_load_data" events.
	self.emit_signal ("before_load_data"); self._module_data_crud (1); self.emit_signal ("after_load_data");

# Apply the module firsts treatments.
func _on_module_enabled () -> void: self._fix_data_manager_events (self.get_prop ("DataManager") > GameDataManager.NONE);

# Saves the module data dynamically.
func _dynamic_save_data () -> void: if self.is_unlock () and self.get_prop ("SaveData"): self._update_data_manager ();

############################################################################### [Availables features] ########################################################################
"""@Description: Returns the version a module."""
static func get_version () -> String: return "0.2.3";

"""@Description: Returns all origins of a module."""
static func get_origin_name () -> String: return "MegaAssets.Module.Indestructible.Recordable";

"""@Description: Is the base class for all modules is serializable ?"""
static func is_saveable () -> bool: return true;

"""@Description: Returns a module class type."""
func get_class (): return "Recordable";

"""@Description: Returns the web link of "Godot Mega Assets" framework."""
static func get_source () -> String: return "https://godot-mega-assets.herokuapp.com/docs/bases/recordable";

"""@Description: Destroys the given properties from his name from "__props__" dictionary."""
func destroy_props (source, delay: float = 0.0) -> void:
	# Waiting for the given delay and destroys the passed property(es) and listen a certain properties.
	if delay > 0.0 and !Engine.editor_hint: yield (self.get_tree ().create_timer (delay), "timeout"); .destroy_props (source);
	# "AutoCompile" module property exists.
	if self.get_prop ("AutoCompile") is bool:
		# "GlobalKey" property has been destroyed.
		if not self.get_prop ("GlobalKey") is String: _auto_compile_listeners.erase ("GlobalKey");
		# "Section" property has been destroyed.
		if not self.get_prop ("Section") is String: _auto_compile_listeners.erase ("Section");
		# Overrides "attach" key of "AutoCompile" module property.
		self.override_prop (Dictionary ({attach = self._auto_compile_listeners}), "AutoCompile");
	# "DataManager" module property exists.
	if self.get_prop ("DataManager") is int:
		# "GlobalKey" property has been destroyed.
		if not self.get_prop ("GlobalKey") is String: _data_manager_listeners.erase ("GlobalKey");
		# "Section" property has been destroyed.
		if not self.get_prop ("Section") is String: _data_manager_listeners.erase ("Section");
		# "Checkpoint" property has been destroyed.
		if not self.get_prop ("Checkpoint") is String: _data_manager_listeners.erase ("Checkpoint");
		# "LoadData" property has been destroyed.
		if not self.get_prop ("LoadData") is bool: _data_manager_listeners.erase ("LoadData");
		# "SaveData" property has been destroyed.
		if not self.get_prop ("SaveData") is bool: _data_manager_listeners.erase ("SaveData");
		# Overrides "attach" key of "DataManager" module property.
		self.override_prop (Dictionary ({attach = self._data_manager_listeners}), "DataManager");

"""@Description: Determines whether the data within of a module have been saved into the game data manager. It is only available on saveable modules."""
func is_saved () -> bool: return self._module_data_crud (2) if self.is_unlock () else false;

"""
	@Description: Updates the game data manager. This function is only available on saveable modules.
	@Parameters:
		float delay: What is the timeout before updating module data ?
"""
func update_data (delay: float = 0.0) -> void:
	# The module is it enabled ?
	if self.is_unlock ():
		# Waiting for the given delay and updates the data manager with the module property(ies) data.
		if delay > 0.0 and !Engine.editor_hint: yield (self.get_tree ().create_timer (delay), "timeout"); self._update_data_manager ();

"""
	@Description: Back up data of a module using the game's data management system. Note that it is not recommended to use this method when you want to make
		several backups at the same time. This function is only available on saveable modules.
	@Parameters:
		float delay: What is the timeout before saving module data ?
"""
func save_data (delay: float = 0.0) -> void:
	# The module is it enabled ?
	if self.is_unlock () and self._check_data_manager (false, true) is bool:
		# Waiting for the given delay and saves the module data from the target data manager.
		if delay > 0.0 and !Engine.editor_hint: yield (self.get_tree ().create_timer (delay), "timeout"); self._save_module_data ();

"""
	@Description: Loads data from a module using the game's data management system. This function is only available on saveable modules.
	@Parameters:
		float delay: What is the timeout before updating module data ?
"""
func load_data (delay: float = 0.0) -> void:
	# The module is it enabled ?
	if self.is_unlock ():
		# Waiting for the given delay and loads the module data from the target data manager.
		if delay > 0.0 and !Engine.editor_hint: yield (self.get_tree ().create_timer (delay), "timeout"); self._load_module_data ();

"""
	@Description: Destroys all data linked to a data manager module. Warning ! there will be no going back after the destruction of the latter.
		This function is only available on modules saveable.
	@Parameters:
		float delay: What is the timeout before updating module data ?
"""
func remove_data (delay: float = 0.0) -> void:
	# The module is it enabled ?
	if self.is_unlock ():
		# Contains the target game data manager.
		var manager_data = self._check_data_manager (true, true);
		# A data manager has been found.
		if manager_data is Array:
			# Waiting for the given delay and thrown "before_destroy_data" event.
			if delay > 0.0 and !Engine.editor_hint: yield (self.get_tree ().create_timer (delay), "timeout"); self.emit_signal ("before_destroy_data");
			# A container has been specified.
			if not manager_data [1].empty ():
				# For game saves manager.
				if self._data_manager is SaveLoadFx: self._data_manager.destroy_checkpoints (manager_data [1]);
				# For game configurations manager.
				else: self._data_manager.destroy_sections (manager_data [0]);
			# Destroys all associated module key(s) from the target container.
			elif self._data_manager is SaveLoadFx:
				# Destroys all saveable property(ies) from the target data manager.
				for prop in self.__props__:
					# Is it a saveable property ?
					if self.__props__ [prop].saveable: self._data_manager.destroy_keys (manager_data [2] + (prop + ".prop").get_file ().split ('.') [0]);
			# Thrown "after_destroy_data" event.
			self.emit_signal ("after_destroy_data");

"""
	@Description: Restarts a module. Made very careful during module reboots. This can be problematic in certain cases.
	@Parameters:
		float delay: What is the timeout before restarting module ?
"""
func restart (delay: float = 0.0) -> void:
	# The module is it enabled ?
	if self.is_unlock ():
		# Waiting for the given delay and resets all module particulars properties.
		if delay > 0.0 and !Engine.editor_hint: yield (self.get_tree ().create_timer (delay), "timeout"); _data_manager = null;
		# Disconnects this module reference from "enabled" signal.
		if self.is_connected ("enabled", self, "_on_module_enabled") && self.disconnect ("enabled", self, "_on_module_enabled") != OK: pass;
		# Restarts the module.
		self._enter_tree (); self._ready ();

"""
	@Description: Opens the documentation associated with the class in question.
	@Parameters:
		Node object: Which node will be considered to perform the different operations ?
		String feature: The documentation will target which functionality of style ?
		float delay: What is the downtime before the opening of the documentation ?
"""
static func open_doc (object: Node, feature: String = '', delay: float = 0.0) -> void:
	# Waiting for the user delay.
	if delay > 0.0 and !Engine.editor_hint: yield (object.get_tree ().create_timer (delay), "timeout");
	# Open the default user browser with the class documentation path.
	if OS.shell_open (get_source () + (('#' + feature.lstrip ('(').rstrip ('(').lstrip (')').rstrip (')')) if not feature.empty () else '')) != OK: pass;
