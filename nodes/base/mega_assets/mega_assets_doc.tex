% Document type and package imports.
\documentclass[a4paper, 11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{charter}
\usepackage[top = 2cm, bottom = 2cm, left = 1cm, right = 1cm]{geometry}
\usepackage{setspace}
\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{tocloft}

% Preanblue.
\onehalfspacing
\definecolor{gray}{rgb}{0.4, 0.4, 0.4}
\cftsetindents{section}{1em}{2em}
\definecolor{silver}{rgb}{0.95, 0.95, 0.95}
\renewcommand{\thesection}{\Roman{section} --}
\definecolor{darkgreen}{HTML}{1E8C15}
\definecolor{godotnumber}{HTML}{a1ffe0}
\definecolor{godotcomment}{rgb}{0.2, 0.2, 0.2}
\definecolor{godotstring}{HTML}{e2b810}
\lstset {frame=tb, language=Python, aboveskip=5mm, belowskip=5mm, showstringspaces=false, columns=flexible,
	basicstyle={\texttt{}}, numberstyle=\textcolor{godotnumber}, keywordstyle=\color{red}, tabsize=4,
	commentstyle=\textcolor{godotcomment}, stringstyle=\textcolor{godotstring}, breaklines=true,
	breakatwhitespace=true
} \hypersetup {colorlinks=true, linkcolor=blue, urlcolor=blue, pdftitle={MegaAssets doc}}

% The start of the article.
\begin{document}
	% Change document background to silver color.
	\pagecolor{silver}
	% MeagAssets module description.
	\huge{\hspace{14.5cm}\textit{\textbf{\textcolor{darkgreen}{MegaAssets}}}}\large{} \tableofcontents 
	\newpage
	% Godot Mega Assets general features.
	\section{Définition}
	\textcolor{darkgreen}{\textbf{MegaAssets}} est une classe possèdant une multitude de fonctions très 
	utiles et interressantes dont le développeur pourra s'en servir pour aller plus vite dans ces 
	programmations. C'est également une bibliothèque de \textbf{bas niveau} sur lequel se base les modules 
	(\textbf{haut niveau}) pour fournir un bon rendement à leurs utilisateurs. Le développeur peut créé des 
	classes, toutes dérivées de la classe \textcolor{darkgreen}{\textbf{MegaAssets}}.\\
	\textcolor{red}{\textbf{NB: Ne tentez jamais d'instancier \textcolor{darkgreen}{\textbf{MegaAssets}} si 
	vous tenez à éviter de maquier la console de votre moteur de rouge.}}

	% Mega Assets availables features.
	\section{Fonctionnalités disponibles}
	% Dictionary | String get_properties_data () method description.
	\begin{description}
		\item [+ \textcolor{darkgreen}{Dictionary | String} \textcolor{blue}{get\_properties\_data} (json = 
		false):] Renvoie les données de toutes les \\propriétés appartenant au script en question.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{bool} json}:] Voulez-vous renvoyer les données au format 
			(.json) ?\\
		\end{itemize}
	\end{description}
	% Dictionary | String get_cash () method description.
	\begin{description}
		\item [+ \textcolor{darkgreen}{Dictionary | String} \textcolor{blue}{get\_cash} (json = false):] 
		Renvoie les données sur les caches éffectuées au cours de certains traitements.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{bool} json}:] Voulez-vous renvoyer les données au format 
			(.json) ?\\
		\end{itemize}
	\end{description}
	% Static bool is_child_of () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_child\_of} (nodes, others):] Détermine
		si un ou plusieurs noeud(s) sont les \\enfant(s) d'un ou plusieurs autre(s) noeud(s).
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node | Array} nodes}:] Contient le(s) premier(s)
			noeud(s) à ciblé(s).
			\item [>> \textbf{\textcolor{darkgreen}{Node | Array} others}:] Contient le(s) deuxième(s)
			noeud(s) à ciblé(s).
			\item [>> \textbf{\textcolor{red}{bool} recursive}:] La vérification d'enfant sera t-elle
			récursive ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called on first game execution.
		func _ready ():
			# Check a certains elements.
			print (MegaAssets.is_child_of ([$Sprite, self], self.get_viewport (), true));
				# Return true
			print (MegaAssets.is_child_of ([$Sprite, self], self.get_viewport (), false));
				# Return false
	\end{lstlisting}
	% Static void output () method description.
	\newpage \begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{\hypertarget{output}{output}} (message, type, 
		object, delay = 0.0):] Affiche le contenu du paramètre \textit{\textcolor{gray}{\\message}} dans la 
		console de l'éditeur.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} message}:] Contient le méssage à affiché.
			\item [>> \textbf{\textcolor{red}{int} type}:] Contient le type du méssage qui sera affiché. Les 
			valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Message.NORMAL} ou \textcolor{blue}{0}}:] 
				Afficher un méssage ordinaire.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Message.WARNING} ou \textcolor{blue}{1}}:] 
				Afficher un méssage d'alerte.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Message.ERROR} ou \textcolor{blue}{2}}:] 
				Afficher un méssage d'erreur.
			\end{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'affichage du 
			méssage ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called on first game execution.
		func _ready ():
			# Show a normal message.
			MegaAssets.output ("Normal message", MegaAssets.Message.NORMAL, self);
			# Show a warning message.
			MegaAssets.output ("Warning message", MegaAssets.Message.WARNING, self);
			# Show an error message.
			MegaAssets.output ("Error message", MegaAssets.Message.ERROR, self);
	\end{lstlisting}
	% Static bool is_child () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_child} (nodes):] Détermine si un ou 
		plusieurs noeud(s) sont considéré(s) comme des enfant(s) dans l'arbre de la scène.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node | Array} nodes}:] Contient le(s) noeud(s) à 
			ciblé(s).\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called on first game execution.
		func _ready ():
			# Check a certains elements are child.
			print (MegaAssets.is_child ([$Sun, $effect, $Camera, self.get_viewport ()]));
				# Return false
			print (MegaAssets.is_child ([$Sun, $effect, $Camera, self]));
				# Return true
	\end{lstlisting}
	% Static bool is_parent () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_parent} (nodes):] Détermine si un ou 
		plusieurs noeud(s) sont considéré(s) comme des parent(s) dans l'arbre de la scène.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node | Array} nodes}:] Contient le(s) noeud(s) à 
			ciblé(s).\\
		\end{itemize}
	\end{description}
	\newpage \textbf{Code: GDScript}
	\begin{lstlisting}
		# Called on first game execution.
		func _ready ():
			# Check a certains elements are child.
			print (MegaAssets.is_parent ([self, self.get_viewport ()]));
				# Return true
			print (MegaAssets.is_parent ([$Sun, $effect, $Camera, self]));
				# Return false
	\end{lstlisting}
	% Static bool is_game_initialised () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_game\_initialised} ():] Détermine si le 
		jeu est initialisé ou pas.\\
	\end{description}
	% Static void re_parent () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{re\_parent} (nodes, nparents, object, 
		reversed = false, delay = 0.0, interval = 0.0):] Change le parent d'un ou de plusieurs noeud(s) 
		donné(s).
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{NodePath | String | PoolStringArray} nodes}:] Contient l
			e(s) chemin(s) de(s) noeud(s) que l'on veut ciblé(s).
			\item [>> \textbf{\textcolor{darkgreen}{NodePath | String | PoolStringArray} nparents}:]
			Contient le(s) chemin(s) de(s) future parent(s) du/des noeud(s) ciblé(s).
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{bool} reversed}:] Voulez-vous inverser le sens du traitement à 
			éffectué ?
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant le changement ?
			\item [>> \textbf{\textcolor{red}{float} interval}:] Quel est le délai avant chaque changement ?
			Notez que ce paramètre est utilisé lorsqu'on éffectue plusieurs changements de parent sur 
			plusieurs noeuds à la fois.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called on first game execution.
		func _ready ():
			# Let's change a certains elements parent.
			MegaAssets.re_parent (["Camera", "Weapon", "Gun"], "Player", self, true, 0.0, 5.0);
			MegaAssets.re_parent ("effect/Navigation", '.', self, false, 15.0);
	\end{lstlisting}
	% Static void dont_destroy_on_load () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{dont\_destroy\_on\_load} (nodes, obj,
		reversed = false, delay = 0.0, interval = 0.0):] Rend indestructible un ou plusieurs noeud(s) 
		donné(s). Ce(s) dernier(s) sera/ont donc toujours présent au changement de scène.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{NodePath | String | PoolStringArray} nodes}:] Contient
			le(s) chemin(s) de(s) noeud(s) que l'on veut rendre indestructible.
			\item [>> \textbf{\textcolor{darkgreen}{Node} obj}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{bool} reversed}:] Voulez-vous inverser le sens du traitement à 
			éffectué ?
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant cette action ?
			\item [>> \textbf{\textcolor{red}{float} interval}:] Quel est le délai avant chaque changement ?
			Notez que ce paramètre est utilisé lorsqu'on éffectue plusieurs indestructions sur plusieurs 
			noeuds à la fois.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called on first game execution.
		func _ready ():
			# Let's make indestructibles nodes.
			MegaAssets.dont_destroy_on_load (["Camera", "Weapon", "Gun"], self);
			MegaAssets.dont_destroy_on_load ("GameData", self.get_node ("DataManager"));
	\end{lstlisting}
	% Static void move_node () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{move\_node} (node, other, position, object, 
		delay = 0.0):] Déplace un noeud dans un autre noeud.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{NodePath | String} node}:] Contient le noeud que l'on 
			veut déplacé.
			\item [>> \textbf{\textcolor{darkgreen}{NodePath | String} other}:] Contient le future parent du 
			noeud à déplacé.
			\item [>> \textbf{\textcolor{red}{int} position}:] Quelle position hiéarchique occupera le 
			future enfant du paramètre \textit{\textcolor{gray}{other}} ? Par défaut, l'enfant sera ajouté 
			en dernière position.
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant le déplacement ?
			\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called on first game execution.
		func _ready ():
			# Let's move some nodes.
			MegaAssets.move_node ("Camera", "Player", 0, self);
			MegaAssets.move_node ("Navigation/NavigationMeshInstance", '.', 3, self, 5.0);
	\end{lstlisting}
	% Static void invoke () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{invoke} (mname, params, object, delay = 
		0.0):] Appel la méthode nommée dans le paramètre \textit{\textcolor{gray}{mname}} avec un certain 
		temps.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} mname}:] Contient le nom de la méthode à 
			appelée.
			\item [>> \textbf{\textcolor{darkgreen}{Array} params}:] Contient les values des paramètres de 
			la méthode ciblée.
			\item [>> \textbf{\textcolor{darkgreen}{Object} object}:] Contient l'instance de l'objet 
			possédant la méthode à appelée.
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'appel ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Method1.
		func method1 (value): return value;
		# Method2.
		func method2 (a: float = 2.569, b: int = 25): print ("The Result is: ", (a + b));
		# Called on first game execution.
		func _ready ():
			# Let's call some methods.
			MegaAssets.invoke ("method2", [15, 25], self, 2.0);
			print (MegaAssets.invoke ("method1", ["A test for invoke method"], self));
	\end{lstlisting}
	% Void invoke_repeating () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{\hypertarget{invokerepeating}{invoke\_repeating}} 
		(mname, params, instance = self, count = 1, interval = 0.0):] Appelle la méthode nommée dans le 
		paramètre \textit{\textcolor{gray}{mname}} de façon répétée en fonction du paramètre 
		\textit{\textcolor{gray}{count}}. Notez qu'une valeur négative au niveau de ce dernier engendrera un 
		appel infini. La valeur nulle n'engendre aucun appelle.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} mname}:] Contient le nom de la méthode à 
			appelée.
			\item [>> \textbf{\textcolor{darkgreen}{Array} params}:] Contient les values des paramètres de 
			la méthode ciblée.
			\item [>> \textbf{\textcolor{darkgreen}{Object} instance}:] Contient l'instance de l'objet 
			possédant la méthode à appelée.
			\item [>> \textbf{\textcolor{red}{int} count}:] Combien de fois la méthode ciblée sera appelée ?
			\item [>> \textbf{\textcolor{red}{float} interval}:] Quel est le temps mort avant chaque l'appel 
			?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		extends MegaAssets;
		func method1 (): print ("Call me !");
		func method2 (): print ("Repeat call !");
		func method3 (): print ("Infinite call !");
		# Called on first game execution.
		func _ready ():
			# Call method1 once.
			self.invoke_repeating ("method1", [], self);
			# Call method2 5 times.
			self.invoke_repeating ("method2", [], self, 5);
			# Infinite call on method3.
			self.invoke_repeating ("method3", [], self, -1, 1.0);
			# No call.
			self.invoke_repeating ("method1", [], self, 0);
	\end{lstlisting}
	% Bool is_invoking () method description.
	\begin{description}
		\item [+ \textcolor{red}{bool} \textcolor{blue}{is\_invoking} (mname):] Détermine si une méthode est 
		prise dans le processus d'appel répété provoqué par la fonction \textit{\textcolor{blue}
		{\textit{\hyperlink{invokerepeating}{invoke\_repeating ()}}}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} mname}:] Contient le nom de la méthode ciblée.\\
		\end{itemize}
	\end{description}
	\newpage \textbf{Code: GDScript}
	\begin{lstlisting}
		extends MegaAssets;
		func method1 (): print ("Call me !");
		func method3 (): print ("Infinite call !");
		# Called on first game execution.
		func _ready ():
			# Call method1 once.
			self.invoke_repeating ("method1", [], self);
			# Infinite call on method3.
			self.invoke_repeating ("method3", [], self, -1, 1.0);
			# The method1 is it invoking ?
			print (self.is_invoking ("method1")); # Return false
			# The method3 is it invoking ?
			print (self.is_invoking ("method3")); # Return true
	\end{lstlisting}
	% Void cancel_invoke () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{cancel\_invoke} (mname, callback = \{\}, delay =
		0.0):] Annule le processus d'appel répété sur une méthode donnée.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} mname}:] Contient le nom de la méthode ciblée.
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} callback}:] Contient des informations sur la
			méthode à exécutée lorsque \\l'invoquation d'une méthode a été éffectuée. Ce dictionaire
			supporte les clés suivantes:
			\begin{itemize}
			   \item[• \textbf{\textcolor{darkgreen}{String | NodePath} source}:] Contient l'addresse de la
			   méthode à ciblée. La présence de cette clé n'est pas obligatoire. Dans ce cas, on considéra
			   que la méthode référée se trouve sur la référence actuelle.
			   \item[• \textbf{\textcolor{darkgreen}{String} method}:] Contient le nom de la méthode à 
			   exécutée. L'utilisation de cette clé est obligatoire.
			\end{itemize}
			Notez que la méthode à exécutée doit possédée qu'un seul paramètre pour contenir le nom de la
			méthode ayant été annulée.
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'annulation ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		extends MegaAssets;
		func method3 (): print ("Infinite call !");
		func cancel_msg (method_name):
			# Print a message.
			print ("method3 call is canceled !");
			# The method3 is it invoking again ?
			print ("method3 invoking state: ", self.is_invoking (method_name)); # Return false
		# Called on first game execution.
		func _ready ():
			# Infinite call on method3.
			self.invoke_repeating ("method3", [], self, -1, 1.0);
			# The method3 is it invoking ?
			if self.is_invoking ("method3"):
				# Stop method3 call after 10 secondes.
				self.cancel_invoke ("method3", Dictionary ({method = "cancel_msg"}), 10);
	\end{lstlisting}
	% Static Node | Array search () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Node | Array} \textcolor{blue}{search} (id, 
		ref, prop = 3, count = -1, inv = false, rec = true)]: Cherche \\un ou plusieurs noeud(s) donné(s) 
		dans l'arbre de la scène.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String | PoolStringArray | Array} id}:] Contient le nom/
			groupe/classe du/des noeud(s) à \\recherché(s).
			\item [>> \textbf{\textcolor{darkgreen}{Node} ref}:] Contient le noeud de référence de la
			recherche.
			\item [>> \textbf{\textcolor{red}{int} prop}:] Par quel moyen la recherche sera faite ? 
			Les valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProperty.NAME} ou \textcolor{blue}{0}}:] 
				Trouve un noeud en utilisant son nom.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProperty.GROUP} ou \textcolor{blue}{1}}:] 
				Trouve un noeud en utilisant le nom de son groupe.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProerty.TYPE} ou \textcolor{blue}{2}}:] 
				Trouve un noeud en utilisant le nom de sa classe.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProerty.ANY} ou \textcolor{blue}{3}}:] 
				Trouve un noeud en utilisant l'un des trois moyens cités plus haut.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{int} count}:] Combien de résultat seront renvoyés ? Notez 
			qu'une valeur négative à ce niveau engendrera le renvoie de tous les résultats trouvés cours de 
			la recherche.
			\item [>> \textbf{\textcolor{red}{bool} inv}:] Voulez-vous inverser le sens du traitement à 
			éffectué ?
			\item [>> \textbf{\textcolor{red}{bool} rec}:] Voulez-vous utiliser un programme récursive pour
			trouver le(s) noeud(s) \\recherché(s) ?\\
		\end{itemize}
	\end{description}
	% Static bool contains () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{contains} (id, scope, prop = 3, rec = true):] 
		Détermine si le(s) identifiant(s) \\donné(s) sont tous présent(s) dans un ou plusieurs noeud(s)
		donné(s) dans l'arbre de la scène.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String | PoolStringArray | Array} id}:] Contient le nom/
			groupe/classe du/des noeud(s) à \\recherché(s).
			\item [>> \textbf{\textcolor{darkgreen}{Node | Array} scope}:] Contient le(s) noeud(s) de
			référence(s) de la recherche. C'est aussi la portée de la recherche. N'utilisez que dans ce 
			paramètre, des objets dérivant de la classe
			\href{https://docs.godotengine.org/fr/stable/classes/class_node.html}
			{\textit{\textcolor{darkgreen}{Node}}}.
			\item [>> \textbf{\textcolor{red}{int} prop}:] Par quelle moyen la recherche sera faite ? Les 
			valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProperty.NAME} ou \textcolor{blue}{0}}:] 
				Trouve un noeud en utilisant son nom.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProperty.GROUP} ou \textcolor{blue}{1}}:] 
				Trouve un noeud en utilisant le nom de son groupe.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProerty.TYPE} ou \textcolor{blue}{2}}:] 
				Trouve un noeud en utilisant le nom de sa classe.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProerty.ANY} ou \textcolor{blue}{3}}:] 
				Trouve un noeud en utilisant l'un des trois moyens cités plus haut.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{bool} rec}:] Voulez-vous utiliser un programme récursive pour 
			trouver le(s) noeud(s) \\recherché(s) ?\\
		\end{itemize}
	\end{description}
	% Static bool is_indestructible () method description.
	\newpage \begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_indestructible} (id, object, property = 
		3):] Détermine si un ou plusieurs noeud(s) peut(vent) être détruit au changement d'une scène.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String | PoolStringArray | Array} id}:] Contient le nom/
			groupe/classe du/des noeud(s) à \\recherché(s).
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{int} property}:] Par quelle moyen la recherche sera faite ?
			Les valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProperty.NAME} ou \textcolor{blue}{0}}:] 
				Trouve un noeud en utilisant son nom.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProperty.GROUP} ou \textcolor{blue}{1}}:] 
				Trouve un noeud en utilisant le nom de son groupe.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProerty.TYPE} ou \textcolor{blue}{2}}:] 
				Trouve un noeud en utilisant le nom de sa classe.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProerty.ANY} ou \textcolor{blue}{3}}:] 
				Trouve un noeud en utilisant l'un des trois moyens cités plus haut.\\
			\end{itemize}
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called on first game execution.
		func _ready ():
			# Let's make some indestructibles nodes.
			MegaAssets.dont_destroy_on_load (["Camera", "Sprite"], self);
			# The both nodes is it don't destroy ?
			print (MegaAssets.is_indestructible (["Camera", "Sprite"], self)); # Will return false
			# Wait for idle frame.
			yield (self.get_tree (), "idle_frame");
			# The both nodes is it don't destroy ?
			print (MegaAssets.is_indestructible (["Camera", "Sprite"], self)); # Will return true
	\end{lstlisting}
	% Static Node | Array get_indestructible () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Node | Array} \textcolor{blue}
		{get\_indestructible} (id, obj, prop = 3, count = -1, inv = false, rec = true):] Cherche un ou 
		plusieurs noeud(s) indestructible(s) donné(s) dans l'arbre de la scène. Notez que cette méthode ne
		renvoie que les noeuds se trouvant au sein du noeud \textit{\textcolor{gray}{DontDestroyOnLoad}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String | PoolStringArray | Array} id}:] Contient le nom/
			groupe/classe du/des noeud(s) à \\recherché(s).
			\item [>> \textbf{\textcolor{darkgreen}{Node} obj}:] Quel noeud sera considéré pour éffectuer 
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{int} prop}:] Par quelle moyen la recherche sera faite ? Les 
			valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProperty.NAME} ou \textcolor{blue}{0}}:] 
				Trouve un noeud en utilisant son nom.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProperty.GROUP} ou \textcolor{blue}{1}}:] 
				Trouve un noeud en utilisant le nom de son groupe.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProerty.TYPE} ou \textcolor{blue}{2}}:] 
				Trouve un noeud en utilisant le nom de sa classe.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.NodeProerty.ANY} ou \textcolor{blue}{3}}:] 
				Trouve un noeud en utilisant l'un des trois moyens cités plus haut.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{int} count}:] Combien de résultat seront renvoyés ? Notez 
			qu'une valeur négative à ce niveau engendrera le renvoie de tous les résultats trouvés cours de 
			la recherche.
			\item [>> \textbf{\textcolor{red}{bool} inv}:] Voulez-vous inverser le sens du traitement à 
			éffectué ?
			\item [>> \textbf{\textcolor{red}{bool} rec}:] Voulez-vous utiliser un programme récursive pour 
			trouver le(s) noeud(s) \\recherché(s) ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called on first game execution.
		func _ready ():
			# Let's make some indestructibles nodes.
			MegaAssets.dont_destroy_on_load (["Camera", "Sprite"], self);
			# Get insdestuctible "Sprite" node.
			print (MegaAssets.get_indestructible ("Sprite", self)); # Will return null
			# Wait for idle frame.
			yield (self.get_tree (), "idle_frame");
			# Get insdestuctibles "Sprite" and "Camera" nodes.
			print (MegaAssets.get_indestructible (["Camera", "Sprite"], self));
	\end{lstlisting}
	% Static Array get_all_indestructible_nodes () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Array} \textcolor{blue}
		{get\_all\_indestructible\_nodes} (object):] Renvoie tous les noeuds à l'intérieur du \\noeud ayant 
		le nom \textit{\textcolor{gray}{DontDestroyOnLoad}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static Variant get_data_manager () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{get\_data\_manager} 
		(object):] Renvoie le noeud où le nom de la classe est \textit{\textcolor{darkgreen}{\\SaveLoadFx}}
		ou nulle si ce dernier n'est pas définit.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static Variant get_audio_manager () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{get\_audio\_manager} (object):] Renvoie le noeud où le nom de la classe est
		\textit{\textcolor{darkgreen}{\\AudioControllerFx}} ou nulle si ce dernier n'est pas définit.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static Variant get_scenes_manager () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{get\_scenes\_manager} (object):] Renvoie le noeud où le nom de la classe est 
		\textit{\textcolor{darkgreen}{\\ScenesFx}} ou nulle si ce dernier n'est pas définit.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static Variant get_languages_manager () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{get\_languages\_manager} (object):] Renvoie le noeud où le nom de la classe est 
		\textit{\textcolor{darkgreen}{\\LanguagesFx}} ou nulle si ce dernier n'est pas définit.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static Variant get_settings_manager () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{get\_settings\_manager} (object):] Renvoie le noeud où le nom de la classe est 
		\textit{\textcolor{darkgreen}{\\SettingsFx}} ou nulle si ce dernier n'est pas définit.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static Variant get_controllers_manager () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{get\_controllers\_manager} (object):] Renvoie le noeud où le nom de la classe est
		\textit{\textcolor{darkgreen}{ControllersSensorFx}} ou nulle si ce dernier n'est pas définit.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static Variant get_cursor_manager () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{get\_cursor\_manager} (object):] Renvoie le noeud où le nom de la classe est 
		\textit{\textcolor{darkgreen}{\\CursorFx}} ou nulle si ce dernier n'est pas définit.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static Variant get_video_recorder () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{get\_video\_recorder} (object):] Renvoie le noeud où le nom de la classe est 
		\textit{\textcolor{darkgreen}{\\VideoRecorderFx}} ou nulle si ce dernier n'est pas définit.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static Variant get_audio_recorder () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{get\_audio\_recorder} (object):] Renvoie le noeud où le nom de la classe est 
		\textit{\textcolor{darkgreen}{\\AudioRecorderFx}} ou nulle si ce dernier n'est pas définit.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static Variant get_multiplayer_manager () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{get\_multiplayer\_manager} (object):] Renvoie le noeud où le nom de la classe est 
		\textit{\textcolor{darkgreen}{\\MultiplayerFx}} ou nulle si ce dernier n'est pas définit.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static bool index_validation () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{index\_validation} (index, size):] Détermine 
		si un index de position est en dehors des limites d'un tableau ou d'un dictionaire donné.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} index}:] Contient la valeur d'un index.
			\item [>> \textbf{\textcolor{red}{int} size}:] Contient la taille total des éléments d'un
			tableau ou d'un dictionaire.\\
		\end{itemize}
	\end{description}
	% Static bool index_validation_msg () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{index\_validation\_msg} (index, size, message 
		= "", type = 0):] Détermine si un \\index de position est en dehors des limites d'un tableau ou d'un 
		dictionaire donné. Cette méthode affiche le contenu du paramètre \textit{\textcolor{gray}{message}} 
		en fonction de la valeur du paramètre \textit{\textcolor{gray}{type}} lorsque la valeur retournée 
		est \textit{\textcolor{gray}{False}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} index}:] Contient la valeur d'un index.
			\item [>> \textbf{\textcolor{red}{int} size}:] Contient la taille total des éléments d'un
			tableau ou d'un dictionaire.
			\item [>> \textbf{\textcolor{darkgreen}{String} message}:] Contient le méssage à affiché.
			\item [>> \textbf{\textcolor{red}{int} type}:] Contient le type du méssage qui sera affiché. Les 
			valeurs possibles sont celles définient au sein de la méthode \textit{\textcolor{blue}
			{\hyperlink{output}{output} ()}}.\\
		\end{itemize}
	\end{description}
	% Void instanciate () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{\hypertarget{instanciate}{instanciate}} (data, 
		object, delay = 0.0):] Charge et importe un objet externe (prefab) dans l'arbre d'une scène.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} data}:] Contient toutes les données à propos 
			du future objet ciblé. Les clés prises en charge dans ce dictionaire sont:
			\begin{itemize}
				\item[>> \textbf{\textcolor{darkgreen}{String} path}:] Contient le chemin du future objet à 
				chargé. L'utilisation de cette clé est \\obligatoire.
				\item[>> \textbf{\textcolor{darkgreen}{String | NodePath} parent}:] Dans quel parent l'objet 
				sera importé ? Si la valeur précisée est invalide ou s'il n'y a aucune valeur, celle se
				trouvant dans le paramètre \textit{\textcolor{gray}{object}} sera utiliser.
				\item[>> \textbf{\textcolor{darkgreen}{Vector2 | Vector3} position}:] Contient la position 
				du future objet à chargé.
				\item[>> \textbf{\textcolor{darkgreen}{Vector2 | Vector3} rotation}:] Contient la rotation 
				du future objet à chargé.
				\item[>> \textbf{\textcolor{darkgreen}{Vector2 | Vector3} scale}: ] Contient la taille du 
				future objet à chargé.
				\item[>> \textbf{\textcolor{red}{int | float} live = \textcolor{blue}{-1.0}}:] Quel est le 
				délai avant la destruction de l'objet après importation ? Si cette clé n'est pas définit ou
				que vous donnez une valeur négative, l'objet ne se détruirera jamais après avoir été 
				importé. Notez que valeur nulle inhibe l'instance de tout objet.
				\item[>> \textbf{\textcolor{red}{bool} visible = \textcolor{red}{true}}:] Voulez-vous rendre 
				visible votre objet ?
				\item[>> \textbf{\textcolor{red}{bool} background = \textcolor{red}{true}}:] Contrôle le 
				moyen utilisé pour charger un objet. A \textit{\textcolor{gray}{true}}, le \\chargement de 
				l'objet s'éffectue en arrière plan sans bloqué le jeu.
				\item[>> \textbf{\textcolor{red}{bool} open = \textcolor{red}{true}}:] Voulez-vous importer 
				automatiquement l'objet après chargement ?
				\item[>> \textbf{\textcolor{red}{bool} duplicate = \textcolor{red}{false}}:] Force la 
				répétition d'un objet. Notez qu'un objet déjà chargé sur un parent ne peut être recharché.
				C'est pour cela pour avoir quand même le même objet plusieurs fois dans une scène sans avoir
				à éffectué un rechargement complet de ce dernier, il serais préférable de créer une copy
				avec une référence différente de l'original.
				\item[>> \textbf{\textcolor{red}{int} zindex = \textcolor{blue}{-1}}:] Contrôle la position
				hiérarchique d'un objet après son chargement.
				\item[>> \textbf{\textcolor{darkgreen}{String} name}:] Souhaitez-vous donner un nom à votre
				objet après son chargement ?
				\item[>> \textbf{\textcolor{darkgreen}{String | PoolStringArray} groups}:] Souhaitez-vous 
				ajouter de(s) nom(s) de groupe à votre objet après son chargement ?
				\item[>> \textbf{\textcolor{red}{bool} global = \textcolor{red}{false}}:] Désirez-vous 
				affecter les transformations globals de l'objet à naître en fonction des transformations que 
				vous avez données ?
				\item [>> \textbf{\textcolor{darkgreen}{Dictionary} callback}:] Contient des informations 
				sur la méthode à exécutée au cours du \\chargement de l'objet en question. Ce dictionaire
				supporte les clés suivantes:
			    \begin{itemize}
			       \item[• \textbf{\textcolor{darkgreen}{String | NodePath} source}:] Contient l'addresse de 
			       la méthode à ciblée. La présence de cette clé n'est pas obligatoire. Dans ce cas, on
			       considéra que la méthode référée se trouve sur la référence donné dans le paramètre
			       \textit{\textcolor{gray}{object}}.
			       \item[• \textbf{\textcolor{darkgreen}{String} method}:] Contient le nom de la méthode à 
			       exécutée. L'utilisation de cette clé est obligatoire.
			   \end{itemize}
				Notez que la méthode à exécutée doit possédée quatres (04) paramètres à savoir:
				\begin{itemize}
					\item [>> \textbf{\textcolor{darkgreen}{String} id}:] Contiendra le nom du fichier ou du
					l'objet.
					\item [>> \textbf{\textcolor{red}{int} progress}:] Contiendra la progression actuelle de
					l'objet en cours de chargement.
					\item [>> \textbf{\textcolor{darkgreen}{Variant} reference}:] Contiendra la référence de
					l'objet lorsque son chargement aura été éffectué avec succès. Par défaut, vous aurez une
					valeur nulle.
					\item [>> \textbf{\textcolor{darkgreen}{Variant} error}:] Contiendra l'erreur déclenchée
					au cours du chargement de l'objet. Ce \\paramètre vous renvoyera un dictionaire
					contenant les clés: \textit{\textcolor{gray}{message, code}} et \textit{\textcolor{gray}
					{type}} ou nulle si aucune erreur ne s'est levée durant le chargement de l'objet.
				\end{itemize}
			\end{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'importation ?\\
		\end{itemize}
	\end{description}
	\newpage \textbf{Code: GDScript}
	\begin{lstlisting}
		# Display in real time the loading building progress on editor console.
		func load_building (id: String, progress: int, reference, error) -> void:
			# No errors detected.
			if error == null:
				# The destroyed building is loading.
				if reference == null: print (id + " is loading: " + str (progress));
				# The destroyed building is loaded successfully.
				else: print (id + " is loaded successfully: " + str (reference));
			# An error has been thrown.
			else: printerr (error.message);

		# Called on first game execution.
		func _ready ():
			# Let's load a 3d destroyed building.
			MegaAssets.instanciate (Dictionary ({
				parent = '.',
				path = "res://prefabs/destroyed_building/destroyed_building_02.tscn",
				background = true,
				callback = {
					method = "load_building",
					source = '.'
				},
				live = "-1.0",
				visible = true,
				open = true,
				duplicate = false,
				global = false,
				position = [265, 255],
				rotation = "0",
				scale = "(1.0, 1.0, 1.0)",
				name = "MyAwesomeDestroyBuilding",
				groups = ["BigBuilding", "Destroy"],
				zindex = 0
			}), self, 3.0);
	\end{lstlisting}
	% Void instanciates () method description.
	\newpage \begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{\hypertarget{instanciates}{instanciates}} (data, 
		object, async = false, direction = 0, repeat = 1, delay = 0.0):] Charge et importe un ou plusieurs 
		objet(s) externe(s) (prefab) dans l'arbre d'une scène.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} data}:] Contient toutes les données à propos 
			des futures objet(s) ciblé(s). Les clés prises en charge dans ce dictionaire sont:
			\begin{itemize}
				\item[>> \textbf{\textcolor{darkgreen}{String} path}:] Contient le chemin du future objet à 
				chargé. L'utilisation de cette clé est \\obligatoire.
				\item[>> \textbf{\textcolor{darkgreen}{String | NodePath} parent}:] Dans quel parent l'objet 
				sera importé ? Si la valeur précisée est invalide ou s'il n'y a aucune valeur, celle se
				trouvant dans le paramètre \textit{\textcolor{gray}{object}} sera utiliser.
				\item[>> \textbf{\textcolor{darkgreen}{Vector2 | Vector3} position}:] Contient la position 
				du future objet à chargé.
				\item[>> \textbf{\textcolor{darkgreen}{Vector2 | Vector3} rotation}:] Contient la rotation 
				du future objet à chargé.
				\item[>> \textbf{\textcolor{darkgreen}{Vector2 | Vector3} scale}: ] Contient la taille du 
				future objet à chargé.
				\item[>> \textbf{\textcolor{red}{int | float} live = \textcolor{blue}{-1.0}}:] Quel est le 
				délai avant la destruction de l'objet après importation ? Si cette clé n'est pas définit ou
				que vous donnez une valeur négative, l'objet ne se détruirera jamais après avoir été 
				importé. Notez que valeur nulle inhibe l'instance de tout objet.
				\item[>> \textbf{\textcolor{red}{bool} visible = \textcolor{red}{true}}:] Voulez-vous rendre 
				visible votre objet ?
				\item[>> \textbf{\textcolor{red}{int | float} interval = \textcolor{blue}{0.0}}:] Quel est 
				l'intervalle de temps avant chaque chargement ?
				\item[>> \textbf{\textcolor{red}{int} count = \textcolor{blue}{1}}:] Combien de fois l'objet 
				sera charger et importer ? Notez que si vous donné une valeur négative, vous aurez une 
				importation infinie.
				\item[>> \textbf{\textcolor{red}{bool} background = \textcolor{red}{true}}:] Contrôle le 
				moyen utilisé pour charger un objet. A \textit{\textcolor{gray}{true}}, le \\chargement de 
				l'objet s'éffectue en arrière plan sans bloqué le jeu.
				\item[>> \textbf{\textcolor{red}{bool} open = \textcolor{red}{true}}:] Voulez-vous importer 
				automatiquement l'objet après chargement ?
				\item[>> \textbf{\textcolor{red}{bool} duplicate = \textcolor{red}{false}}:] Force la 
				répétition d'un objet. Notez qu'un objet déjà chargé sur un parent ne peut être recharché.
				C'est pour cela pour avoir quand même le même objet plusieurs fois dans une scène sans avoir
				à éffectué un rechargement complet de ce dernier, il serais préférable de créer une copy
				avec une référence différente de l'original.
				\item[>> \textbf{\textcolor{red}{int} zindex = \textcolor{blue}{-1}}:] Contrôle la position
				hiérarchique d'un objet après son chargement.
				\item[>> \textbf{\textcolor{darkgreen}{String} name}:] Souhaitez-vous donner un nom à votre
				objet après son chargement ?
				\item[>> \textbf{\textcolor{darkgreen}{String | PoolStringArray} groups}:] Souhaitez-vous 
				ajouter de(s) nom(s) de groupe à votre objet après son chargement ?
				\item[>> \textbf{\textcolor{red}{bool} global = \textcolor{red}{false}}:] Désirez-vous 
				affecter les transformations globals de l'objet à naître en fonction des transformations que 
				vous avez données ?
				\item [>> \textbf{\textcolor{darkgreen}{Dictionary} callback}:] Contient des informations 
				sur la méthode à exécutée au cours du \\chargement de l'objet en question. Ce dictionaire
				supporte les clés suivantes:
			    \begin{itemize}
			       \item[• \textbf{\textcolor{darkgreen}{String | NodePath} source}:] Contient l'addresse de 
			       la méthode à ciblée. La présence de cette clé n'est pas obligatoire. Dans ce cas, on
			       considéra que la méthode référée se trouve sur la référence donné dans le paramètre
			       \textit{\textcolor{gray}{object}}.
			       \item[• \textbf{\textcolor{darkgreen}{String} method}:] Contient le nom de la méthode à 
			       exécutée. L'utilisation de cette clé est obligatoire.
			   \end{itemize}
				Notez que la méthode à exécutée doit possédée quatres (04) paramètres à savoir:
				\begin{itemize}
					\item [>> \textbf{\textcolor{darkgreen}{String} id}:] Contiendra le nom du fichier ou du
					l'objet.
					\item [>> \textbf{\textcolor{red}{int} progress}:] Contiendra la progression actuelle de
					l'objet en cours de chargement.
					\item [>> \textbf{\textcolor{darkgreen}{Variant} reference}:] Contiendra la référence de
					l'objet lorsque son chargement aura été éffectué avec succès. Par défaut, vous aurez une
					valeur nulle.
					\item [>> \textbf{\textcolor{darkgreen}{Variant} error}:] Contiendra l'erreur déclenchée
					au cours du chargement de l'objet. Ce \\paramètre vous renvoyera un dictionaire
					contenant les clés: \textit{\textcolor{gray}{message, code}} et \textit{\textcolor{gray}
					{type}} ou nulle si aucune erreur ne s'est levée durant le chargement de l'objet.
				\end{itemize}
			\end{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{bool} async}:] Devons-nous charger de façon asynchrône le(s)
			différent(s) objet(s) donné(s) ?
			\item [>> \textbf{\textcolor{red}{int} direction}:] Le chargement des données suivra quelle 
			direction ? Les valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Direction.NORMAL} ou \textcolor{blue}{0}}:] 
				Chargement normal des objets.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Direction.REVERSED} ou \textcolor{blue}{1}}:] 
				Chargement renversé des objets.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Direction.RANDOM} ou \textcolor{blue}{2}}:] 
				Chargement aléatoire des objets.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Direction.ALTERNATE} ou \textcolor{blue}{3}}:] 
				Chargement alterné des objets.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{int} repeat}:] Combien de fois les objets donnés seront 
			chargés ? Une valeur négative entraînera un chargement infinit et une valeur nulle ne provoquera
			pas de chargement.
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant les importations 
			?\\
		\end{itemize}
	\end{description}
	% static bool is_a_number () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_a\_number} (character):] Détermine si un 
		caractère est un nombre.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} character}:] Contient la valeur du caractère en 
			question. Attention ! La taille total du \\paramètre \textit{\textcolor{gray}{character}} doit 
			être égale à 1.\\
		\end{itemize}
	\end{description}
	% Static bool is_full_numbers () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_full\_numbers} (string):] Détermine si 
		une chaîne de caractères est tous en nombre.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient la valeur de la chaîne en 
			question.\\
		\end{itemize}
	\end{description}
	% Static bool is_a_letter () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_a\_letter} (character):] Détermine si un 
		caractère est une lettre.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} character}:] Contient la valeur du caractère en 
			question. Attention ! La taille total du \\paramètre \textit{\textcolor{gray}{character}} doit 
			être égale à 1.\\
		\end{itemize}
	\end{description}
	% Static bool is_full_letters () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_full\_letters} (string):] Détermine si 
		une chaîne de caractères est tous en lettre.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient la valeur de la chaîne en 
			question.\\
		\end{itemize}
	\end{description}
	% Static bool is_upper_case () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_upper\_case} (character):] Détermine si 
		un caractère est une lettre majuscule.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} character}:] Contient la valeur du caractère en 
			question. Attention ! La taille total du \\paramètre \textit{\textcolor{gray}{character}} doit 
			être égale à 1.\\
		\end{itemize}
	\end{description}
	% Static bool is_full_upper_case () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_full\_upper\_case} (string):] Détermine 
		si une chaîne de caractères est tous en \\majuscule.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient la valeur de la chaîne en 
			question.\\
		\end{itemize}
	\end{description}
	% Static bool is_lower_case () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_lower\_case} (character):] Détermine si 
		un caractère est une lettre minuscule.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} character}:] Contient la valeur du caractère en 
			question. Attention ! La taille total du \\paramètre \textit{\textcolor{gray}{character}} doit 
			être égale à 1.\\
		\end{itemize}
	\end{description}
	% Static bool is_full_lower_case () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_full\_lower\_case} (string):] Détermine 
		si une chaîne de caractères est tous en \\minuscule.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient la valeur de la chaîne en 
			question.\\
		\end{itemize}
	\end{description}
	% Static PoolIntArray | int get_numbers_from () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolIntArray} | \textcolor{red}{int} 
		\textcolor{blue}{get\_numbers\_from} (string):] Renvoie tous les caractères jugés \\comme étant des 
		nombres à partir du paramètre \textit{\textcolor{gray}{string}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient la valeur de la chaîne en 
			question.\\
		\end{itemize}
	\end{description}
	% Static PoolStringArray | String get_letters_from () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray | String} \textcolor{blue}
		{get\_letters\_from} (string):] Renvoie tous les caractères jugés \\comme étant des lettres à partir 
		du paramètre \textit{\textcolor{gray}{string}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient la valeur de la chaîne en 
			question.\\
		\end{itemize}
	\end{description}
	% Static PoolStringArray | String get_letters_case_from () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray | String} \textcolor{blue}
		{get\_letters\_case\_from} (string, is\_lower):] Renvoie tous les \\caractères jugés comme étant des 
		lettres minuscules ou majuscules en fonction de \textit{\textcolor{gray}{is\_lower}} à partir du
		paramètre \textit{\textcolor{gray}{string}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient la valeur de la chaîne en 
			question.
			\item [>> \textbf{\textcolor{red}{bool} is\_lower}:] Doit-on renvoyé des caractères minuscules ?
			\\
		\end{itemize}
	\end{description}
	% Static String | int get_hex_symbol () method description.
	\begin{description}
		\item [+ \textcolor{red}{static int} | \textcolor{darkgreen}{String} \textcolor{blue}
		{get\_hex\_symbol} (value, is\_lower = false):] Renvoie la valeur hexadécimal \\correspondant à 
		\textit{\textcolor{gray}{value}}. La valeur qui sera entrée doit être dans l'intervalle [10; 15].
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} value}:] Contient une valeur entière.
			\item [>> \textbf{\textcolor{red}{bool} is\_lower}:] Doit-on renvoyé un caractère minuscule ?\\
		\end{itemize}
	\end{description}
	% Static String | int get_int_from_hex () method description.
	\begin{description}
		\item [+ \textcolor{red}{static int} | \textcolor{darkgreen}{String} \textcolor{blue}
		{get\_int\_from\_hex} (symbol):] Renvoie la correspondance entière de \textit{\textcolor{gray}
		{symbol}}. La valeur qui sera entrée doit être dans l'intervalle [a/A; f/F].
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} symbol}:] Contient un symbol hexadécimal.\\
		\end{itemize}
	\end{description}
	% Static Variant any_to_bit () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{any\_to\_bit} 
		(type, bit, security = true):] Converti n'importe quel type de donnée à n'importe quelle base. 
		Attention ! Les types prises en charge sont: \textit{\textcolor{gray}{int, float}},
		\href{https://docs.godotengine.org/fr/stable/classes/class_string.html}
		{\textit{\textcolor{darkgreen}{String}}},
		\href{https://docs.godotengine.org/fr/stable/classes/class_vector2.html}
		{\textit{\textcolor{darkgreen}{Vector2}}},
		\href{https://docs.godotengine.org/fr/stable/classes/class_vector3.html}
		{\textit{\textcolor{darkgreen}{Vector3}}},
		\href{https://docs.godotengine.org/fr/stable/classes/class_array.html}
		{\textit{\textcolor{darkgreen}{Array}}} et
		\href{https://docs.godotengine.org/fr/stable/classes/class_dictionary.html}
		{\textit{\textcolor{darkgreen}{Dictionary}}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Variant} type}:] Contient une donnée quelconque.
			\item [>> \textbf{\textcolor{red}{int} bit}:] Quelle est la base choisie ?
			\item [>> \textbf{\textcolor{red}{bool} security}:] Voulez-vous mettre une sécurité au résultat 
			final ?\\
		\end{itemize}
	\end{description}
	% Static Variant any_from_bit () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{any\_from\_bit} 
		(coded\_type, bit, security = true):] Renvoie la valeur du type qui avait été codé à la base 
		\textit{\textcolor{gray}{bit}} par la méthode \textit{\textcolor{blue}{\textit{any\_to\_bit ()}}}.
		Cependant, si vous tenez à revoir votre donnée intacte, vous devez utilisez l'une des bases 
		suivantes: 2 à 10 ou 16, tout en sachant que la donnée a été préalablement codée dans l'une des 
		bases recommandées.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String | Array | Dictionary} coded\_type}:] Contient la 
			forme codée de la valeur du type en \\question.
			\item [>> \textbf{\textcolor{red}{int} bit}:] Quelle est la base qui avait été choisie pour le 
			codage ?
			\item [>> \textbf{\textcolor{red}{bool} security}:] Est-ce que la valeur codée avait-elle été 
			sécurisé ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called on first game execution.
		func _ready ():
			# Let's code and decode some variables value.
			print (MegaAssets.any_from_bit (MegaAssets.any_to_bit (true, 8), 8));
			print (MegaAssets.any_from_bit (MegaAssets.any_to_bit (12655666, 3), 3));
			print (MegaAssets.any_from_bit (MegaAssets.any_to_bit (1265.5666, 5), 5));
			print (MegaAssets.any_from_bit (MegaAssets.any_to_bit (Vector2 (5.0, -93.2), 16), 16));
			print (MegaAssets.any_from_bit (MegaAssets.any_to_bit (Vector3.DOWN, 9), 9));
			print (MegaAssets.any_from_bit (MegaAssets.any_to_bit ("Good boxing !", 10), 10));
			print (MegaAssets.any_to_bit ([
				"Rikoudo", 'h', Vector2 (45, -96), true, 25.336, 99, false,
				["edwdrf", true, 9, [Vector2.UP, [Vector3.BACK]]],
				{"a": "b", false: "z", 9: Vector2.AXIS_Y,
				"My dic": {4: -65.02, true: 42, "z": {"x": 22, "y": -66.0225,
				"e": ["awer", "v", [false, 0, -2.15454848]]}}}
			], 16));
			print (MegaAssets.any_from_bit (MegaAssets.any_to_bit ([
				"Rikoudo", 'h', Vector2 (45, -96), true, 25.336, 99, false
			], 6), 6));
	\end{lstlisting}
	% String generate_key () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{generate\_key} 
		(max\_size = 16):] Génère de façon aléatoire une clé.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} max\_size}:] Contient la taille maximale de la clé qui 
			sera générée.\\
		\end{itemize}
	\end{description}
	% PoolStringArray generate_keys () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray} \textcolor{blue} 
		{generate\_keys} (key\_count, max\_size = 16):] Génère de façon aléatoire des clés.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} key\_count}:] Contient le nombre total de clés à 
			générées.
			\item [>> \textbf{\textcolor{red}{int} max\_size}:] Contient la taille maximale des clés qui 
			seront générées.\\
		\end{itemize}
	\end{description}
	% Static String bytes_to_text () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{bytes\_to\_text} 
		(bytes):] Renvoie la correspondance textuelle des \textit{\textcolor{gray}{bytes}} donnés.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{PoolByteArray} bytes}:] Contient un tableau d'octets.\\
		\end{itemize}
	\end{description}
	% Static ImageTexture get_screen_shot () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{ImageTexture} \textcolor{blue}
		{get\_screen\_shot} (object, data = \{\}):] Renvoie une capture d'écran grâce au viewport de
		l'application.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considérer pour 
			éffectuer les différentes opérations ?
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} data}:] Contient les différentes
			configurations à effectuées sur la capture, une fois générée. Ce dictionaire supporte les clés
			suivantes:
			\begin{itemize}
				\item[>> \textbf{\textcolor{darkgreen}{Vector2} size = \textcolor{darkgreen}{Vector2} 
				(\textcolor{blue}{-1}, \textcolor{blue}{-1})}:] Contient la taille de l'image. Si la valeur
				de l'un des \\composants de ce paramètre est négative, celle du viewport sera utiliser pour
				\\redimensionner l'image.\\
				\item[>> \textbf{\textcolor{red}{int} quality = \textcolor{blue}{2}}:] Contient la qualité
				de la résolution de l'image. Les valeurs \\possibles sont celles définient au sein de classe 
				\href{https://docs.godotengine.org/en/stable/classes/class_image.html#class-image-constant-interpolate-bilinear}{\textit{\textcolor{darkgreen}{Image}}} de Godot.
				\\\item[>> \textbf{\textcolor{red}{int} skrink = \textcolor{blue}{0}}:] Contrôle le
				rétrécissement de l'image.\\
				\item[>> \textbf{\textcolor{red}{int} comp\_mode = \textcolor{blue}{1}}:] Quel mode de
				compression voulez-vous adopter pour compresser \\l'image ? Les valeurs possibles sont:
				\begin{itemize}
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageCompression.NONE} ou \textcolor{blue}
					{0}}:] Aucune compression ne sera éffectuée.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageCompression.ETC} ou \textcolor{blue}
					{1}}:] Compression avec en mode \textit{\textcolor{gray}{ETC}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageCompression.ETC2} ou \textcolor{blue}
					{2}}:] Compression avec en mode \textit{\textcolor{gray}{ETC2}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageCompression.S3TC} ou \textcolor{blue}
					{3}}:] Compression avec en mode \textit{\textcolor{gray}{S3TC}}.\\
				\end{itemize}
				\item[>> \textbf{\textcolor{red}{int} comp\_source = \textcolor{blue}{1}}:] A partir de
				quelle source de compression l'image sera compresser ? Les valeurs possibles sont celles
				définient au sein de la classe \href{https://docs.godotengine.org/en/stable/classes/class_image.html#enum-image-compresssource}{\textit{\textcolor{darkgreen}{Image}}} de Godot.
				\textbf{N'utilisez cette clé que si l'image doit être compressée}.\\
				\item[>> \textbf{\textcolor{red}{int} format = \textcolor{blue}{6}}:] Contient le format de
				l'image. \textbf{N'utilisez cette clé que si l'image doit être compressée}. Les valeurs
				possibles sont:
				\begin{itemize}
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageFormat.RH} ou \textcolor{blue}
					{0}}:] Format \textit{\textcolor{gray}{RH}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageFormat.RF} ou \textcolor{blue}
					{1}}:] Format \textit{\textcolor{gray}{RF}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageFormat.RGH} ou \textcolor{blue}
					{2}}:] Format \textit{\textcolor{gray}{RGH}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageFormat.RGF} ou \textcolor{blue}
					{3}}:] Format \textit{\textcolor{gray}{RGF}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageFormat.RGBH} ou \textcolor{blue}
					{4}}:] Format \textit{\textcolor{gray}{RGBH}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageFormat.RGBF} ou \textcolor{blue}
					{5}}:] Format \textit{\textcolor{gray}{RGBF}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageFormat.RGBAH} ou \textcolor{blue}
					{6}}:] Format \textit{\textcolor{gray}{RGBAH}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageFormat.RGBAF} ou \textcolor{blue}
					{7}}:] Format \textit{\textcolor{gray}{RGBAF}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageFormat.RGBA4444} ou \textcolor{blue}
					{8}}:] Format \textit{\textcolor{gray}{RGBA4444}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageFormat.RGBA5551} ou \textcolor{blue}
					{9}}:] Format \textit{\textcolor{gray}{RGBA55551}}.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.ImageFormat.RGBA9995} ou \textcolor{blue}
					{10}}:] Format \textit{\textcolor{gray}{RGBA9995}}.\\
				\end{itemize}
				\item[>> \textbf{\textcolor{red}{float} ratio = \textcolor{blue}{100.0}}:] Quel taux de
				compression voulez-vous appliquer à l'image ? \textbf{N'utilisez cette clé que si l'image
				doit être compressée}.\\
			\end{itemize}
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		extends Sprite;
		# Called on first game execution.
		func _ready ():
			# Let's the current viewport screenshot.
			yield (self.get_tree (), "idle_frame"); yield (self.get_tree (), "idle_frame");
			# Let's change the current sprite texture.
			texture = MegaAssets.get_screen_shot (self);
	\end{lstlisting}
	% Static void create_screen_shot () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{create\_screen\_shot} (path, object, data =
		\{\}, delay = 0.0):] Cré sur le disque dure, une capture de l'écran de l'application.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Contient le chemin de destination de la 
			génération de l'image. Notez que votre image doit être au format (.png).
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considérer pour 
			éffectuer les différentes opérations ?
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} data}:] Contient les différentes
			configurations à effectuées sur la capture, une fois \\générée. Pour avoir plus d'informations,
			consulter la documentation sur la fonction \textit{\textcolor{blue}{get\_screen\_shot ()}}.
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant la création de la 
			capture ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called when the node enters the scene tree for the first time.
		func _ready ():
			# Let's create the game screenshot on the disc after 02 secondes.
			MegaAssets.create_screen_shot ("res://screen_shot01.png", self, {}, 2.0);
	\end{lstlisting}
	% Static String hex_to_raw () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{hex\_to\_raw} 
		(string):] Converti une chaîne brute en hexadécimale.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient une chaîne.\\
		\end{itemize}
	\end{description}
	% Static String raw_to_hex () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{raw\_to\_hex} 
		(string):] Converti une valeur hexadécimale en donnée brute.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient une valeur hexadécimale.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called when the node enters the scene tree for the first time.
		func _ready ():
			# Let's code a string.
			print (MegaAssets.hex_to_raw (MegaAssets.raw_to_hex ("William Hashford")));
				# Will return "William Hashford".
	\end{lstlisting}
	% Static String rotr32 () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{red}{int} \textcolor{blue}{rotr32} (n, r):] Renvoie le 
		\textit{\textcolor{gray}{rotr32}} de deux entiers.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} n}:] Contient une value entière.
			\item [>> \textbf{\textcolor{red}{int} r}:] Contient une value entière.\\
		\end{itemize}
	\end{description}
	% Static String rotl64 () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{red}{int} \textcolor{blue}{rotl64} (n, r):] Renvoie le 
		\textit{\textcolor{gray}{rotl64}} de deux entiers.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} n}:] Contient une value entière.
			\item [>> \textbf{\textcolor{red}{int} r}:] Contient une value entière.\\
		\end{itemize}
	\end{description}
	% Static String encrypt () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{encrypt} (input, key 
		= '', method = 2, schema = 0):] Chiffre une donnée avec une \\certaine clé. Cette fonction supporte 
		plusieurs méthodes de chiffrement.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient l'entrée à chiffrée.
			\textbf{\textcolor{red}{Ne donnez pas une entrée ayant une taille très long si vous tenez à 
			récupéré votre donnée sans perte au cours du processus de \\déchiffrement. Il très important que 
			vous comprenez cela}}.
			\item [>> \textbf{\textcolor{darkgreen}{String} key}:] Contient la clé à utilisée pour chiffrer
			l'entrée. Notez que la taille de cette clé doit être égale à l'une des valeurs suivantes: 16 ou 
			32.
			\item [>> \textbf{\textcolor{red}{int} method}:] Contient la méthode à utilisée pour le 
			chiffrement. Les valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionMethod.AES} ou \textcolor{blue}
				{0}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{AES}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionMethod.ARCFOUR} ou \textcolor{blue}
				{1}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{ARCFOUR}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionMethod.CHACHA} ou \textcolor{blue}
				{2}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{CHACHA}}.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{int} schema}:] Le chiffrement suivra quel schéma ? Les valeurs 
			possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionSchema.BASE64} ou \textcolor{blue}
				{0}}:] Chiffrement avec le schéma \textit{\textcolor{gray}{Base64}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionSchema.HEXADECIMAL} ou
				\textcolor{blue}{1}}:] Chiffrement avec le schéma \textit{\textcolor{gray}{\\Hexadecimal}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionSchema.RAW} ou \textcolor{blue}
				{2}}:] Chiffrement avec le schéma \textit{\textcolor{gray}{Raw}}.\\
			\end{itemize}
		\end{itemize}
	\end{description}
	% Static Variant decrypt () method description.
	\newpage \begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{decrypt} (input, 
		key = '', method = 2, schema = 0):] Déchiffre une donnée avec une certaine clé. Cette fonction 
		supporte plusieurs méthodes de chiffrement. Assurez-vous que la \\donnée est été chiffrée au 
		préalablement avec la fonction \textcolor {blue}{\textit{encrypt ()}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} input}:] Contient l'entrée déjà chiffrée.
			\item [>> \textbf{\textcolor{darkgreen}{String} key}:] Contient la clé qui avait été utilisé 
			pour chiffrer l'entrée en question avec la fonction \textit {\textcolor{gray}{encrypt ()}}.
			Notez que la taille de cette clé doit être égale à l'une des valeurs suivantes: 16 ou 32.
			\item [>> \textbf{\textcolor{red}{int} method}:] Contient la méthode qui avait été utilisé pour
			chiffrer l'entrée en question avec la fonction \textit{\textcolor{blue}{encrypt ()}}. Les
			valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionMethod.AES} ou \textcolor{blue}
				{0}}:] Déchiffrement avec la méthode \textit{\textcolor{gray}{AES}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionMethod.ARCFOUR} ou \textcolor{blue}
				{1}}:] Déchiffrement avec la méthode \textit{\textcolor{gray}{ARCFOUR}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionMethod.CHACHA} ou \textcolor{blue}
				{2}}:] Déchiffrement avec la méthode \textit{\textcolor{gray}{CHACHA}}.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{int} schema}:] Contient le schéma qui avait été utilisé 
			pour chiffrer l'entrée en question avec la fonction \textit{\textcolor{blue}{encrypt ()}}. Les 
			valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionSchema.BASE64} ou \textcolor{blue}
				{0}}:] Chiffrement avec le schéma \textit{\textcolor{gray}{Base64}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionSchema.HEXADECIMAL} ou 
				\textcolor{blue}{1}}:] Chiffrement avec le schéma \textit{\textcolor{gray}{\\Hexadecimal}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionSchema.RAW} ou \textcolor{blue}
				{2}}:] Chiffrement avec le schéma \textit{\textcolor{gray}{Raw}}.\\
			\end{itemize}
		\end{itemize}
	\end{description}
	% Static String hash_var () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{hash\_var} (input, 
		key = '', method = 0, schema = 0):] Hash une donnée avec une \\certaine clé. Cette fonction supporte 
		plusieurs méthodes de hashage.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient l'entrée à hashée.
			\item [>> \textbf{\textcolor{darkgreen}{String} key}:] Contient la clé à utilisée pour hasher
			l'entrée. Notez que la taille de la clé ne doit dépassée 16 octets.
			\item [>> \textbf{\textcolor{red}{int} method}:] Contient la méthode à utilisée pour le hashage. 
			Les valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.HashingMethod.SIP} ou \textcolor{blue}{0}}:] 
				Hashage avec la méthode \textit{\textcolor{gray}{SIP}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.HashingMethod.SHA256} ou \textcolor{blue}
				{1}}:] Hashage avec la méthode \textit{\textcolor{gray}{SHA256}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.HashingMethod.HASHMAC\_SHA256} ou 
				\textcolor{blue}{2}}:] Hashage avec la méthode \textit{\textcolor{gray}{\\HASHMAC\_SHA256}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.HashingMethod.GODOT\_SHA256} ou
				\textcolor{blue}{3}}:] Hashage avec la méthode \textit{\textcolor{gray}{\\GODOT\_SHA256}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.HashingMethod.MD5} ou \textcolor{blue}{4}}:] 
				Hashage avec la méthode \textit{\textcolor{gray}{MD5}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.HashingMethod.AES} ou \textcolor{blue}{5}}:] 
				Hashage avec la méthode \textit{\textcolor{gray}{AES}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.HashingMethod.ARCFOUR} ou \textcolor{blue}
				{6}}:] Hashage avec la méthode \textit{\textcolor{gray}{ARCFOUR}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.HashingMethod.CHACHA} ou \textcolor{blue}
				{7}}:] Hashage avec la méthode \textit{\textcolor{gray}{CHACHA}}.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{int} schema}:] Le hashage suivra quel schéma ? Les valeurs 
			possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionSchema.BASE64} ou \textcolor{blue}
				{0}}:] Hashage avec le schéma Base64.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionSchema.HEXADECIMAL} ou 
				\textcolor{blue}{1}}:] Hashage avec le schéma \\Hexadecimal.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.EncryptionSchema.RAW} ou \textcolor{blue}
				{2}}:] Hashage avec le schéma Raw.\\
			\end{itemize}
		\end{itemize}
	\end{description}
	% Static Variant get_variant () method description.
	\newpage \begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{get\_variant} 
		(string):] Renvoie le type de valeur correspondant à son format texte. \\Attention ! Les types 
		prises en charge sont: \textit{\textcolor{gray}{int, float,
		\href{https://docs.godotengine.org/fr/stable/classes/class_vector2.html}{\textcolor{darkgreen}
		{Vector2}},
		\href{https://docs.godotengine.org/fr/stable/classes/class_vector3.html}{\textcolor{darkgreen}
		{Vector3}},
		\href{https://docs.godotengine.org/fr/stable/classes/class_string.html}{\textcolor{darkgreen}
		{String}}, bool, \href{https://docs.godotengine.org/fr/stable/classes/class_array.html}
		{\textcolor{darkgreen}{Array}} et
		\href{https://docs.godotengine.org/fr/stable/classes/class_dictionary.html}{\textcolor{darkgreen}
		{\\Dictionary}}}}. Notez que l'imbrication de dictionaire et de liste ont été prise en charge.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient la valeur du type en question 
			en chaîne de caractères.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called when the node enters the scene tree for the first time.
		func _ready ():
			print (MegaAssets.get_variant ("[45, 96.14, true, false, (14.1266, 20.148)]") is Array);
				# Will return True.
			print (MegaAssets.get_variant ("58.10") is float); # Will return True.
			print (MegaAssets.get_variant ("10") is int); # Will return True.
			print (MegaAssets.get_variant ("false") is bool); # Will return True.
			print (MegaAssets.get_variant ("(48, 1, 0)") is Vector3); # Will return True.
			print (MegaAssets.get_variant ("(-9, -2.1562)") is Vector2); # Will return True.
	\end{lstlisting}
	% Static void serialize () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{serialize} (data, path, obj, ky = '', 
		mhd = 7, lv = 1, call = \{\}, chek = 0, delay = 0.0)]: Sérialise les données se trouvant dans 
		\textit{\textcolor{gray}{data}} bloquées avec \textit{\textcolor{gray}{key}} et cré ensuite un 
		fichier sur le disque pour contenir le résultat de la sérialisation. Au cours de la sérialisation 
		les données, peuvent être sécurisées en fonction de la méthode de chiffrement et niveau choisi. 
		Notez qu'au même moment, un checksum est généré par rapport au fichier contenant les données qui 
		ont été \\sérialisées blockant ainsi toute modification extérieur.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} data}:] Contient toutes les données qui 
			seront sauvegardées. \textbf{\textcolor{red}{Ne donnez pas des clés et valeurs ayant une taille 
			très long si vous tenez à récupéré vos données sans perte au cours du processus de 
			désérialisation. Il très important que vous sachez cela}}. Vos clés et valeurs sont d'abord
			converti ensemble en chaîne de caractères avant d'être chiffré.
			\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Où voulez-vous créer le fichier de 
			sauvegarde ?
			\item [>> \textbf{\textcolor{darkgreen}{Node} obj}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{darkgreen}{String} ky}:] Quel est le mot de passe des données ? 
			Notez que la taille de cette clé doit être égale à l'une des valeurs suivantes: 16 ou 32.
			\item [>> \textbf{\textcolor{red}{int} mhd}:] Quelle sera la méthode à utilisée pour 
			sécuriser les données ? Les méthodes prises en charge sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.NONE} ou \textcolor{blue}{0}}:] 
				Aucune sécurité ne sera appliquée au cours de la sauvegarde des données.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.AES} ou \textcolor{blue}{1}}:] 
				Chiffrement avec la méthode \textit{\textcolor{gray}{AES}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.ARCFOUR} ou \textcolor{blue}
				{2}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{ARCFOUR}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.CHACHA} ou \textcolor{blue}
				{3}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{CHACHA}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.BINARY} ou \textcolor{blue}
				{4}}:] Codage en \textit{\textcolor{gray}{Binaire}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.HEXADECIMAL} ou 
				\textcolor{blue}{5}}:] Codage en \textit{\textcolor{gray}{Hexadécimal}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.OCTAL} ou \textcolor{blue}
				{6}}:] Codage en \textit{\textcolor{gray}{Octal}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.GODOT} ou \textcolor{blue}
				{7}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{GODOT}}.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{int} lv}:] Quel niveau de sécurité voulez-vous utiliser ?
			Les niveaux de sécurité prises en charge sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.SIMPLE} ou \textcolor{blue}
				{0}}:] Simple niveau de sécurité.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.NORMAL} ou \textcolor{blue}
				{1}}:] Niveau de sécurité normal.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.ADVANCED} ou \textcolor{blue}
				{2}}:] Niveau de sécurité avancé.
			\end{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} call}:] Contient des informations sur la
			méthode à exécutée au cours de la sauvegarde d'un fichier. Ce dictionaire supporte les clés
			suivantes:
			\begin{itemize}
			   \item[• \textbf{\textcolor{darkgreen}{String | NodePath} source}:] Contient l'addresse de la 
			   méthode à ciblée. La présence de cette clé n'est pas obligatoire. Dans ce cas, on considéra
			   que la méthode référée se trouve sur celle se trouvant dans le paramètre
			   \textit{\textcolor{gray}{obj}}.
			   \item[• \textbf{\textcolor{darkgreen}{String} method}:] Contient le nom de la méthode à 
			   exécutée. L'utilisation de cette clé est obligatoire.
			\end{itemize}
			Notez que la méthode à exécutée doit possédée trois (03) paramètres à savoir:
			\begin{itemize}
				\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Contiendra le chemin pointant vers
				le fichier en cours de sauvegarde.
				\item [>> \textbf{\textcolor{red}{int} progress}:] Contiendra la progression actuelle de
				fichier en cours de sauvegarde.
				\item [>> \textbf{\textcolor{darkgreen}{Variant} error}:] Contiendra l'erreur déclenchée au
				cours de la sauvegarde des données. Ce \\paramètre vous renvoyera un dictionaire contenant
				les clés: \textit{\textcolor{gray}{message, code}} et \textit{\textcolor{gray}{type}} ou
				nulle si aucune erreur ne s'est levée durant la sauvegarde des données.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{int} chek}:] Quelle méthode de chiffrement voulez-vous 
			utiliser pour générer le checksum du fichier de sauvegarde ? Les méthodes disponibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Checksum.NONE} ou \textcolor{blue}{0}}:] Aucun 
				checksum ne sera générer.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Checksum.MD5} ou \textcolor{blue}{1}}:] 
				Chiffrement avec la méthode MD5.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Checksum.SHA256} ou \textcolor{blue}{2}}:] 
				Chiffrement avec la méthode SHA256.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant la sérialisation
			des données ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Save data debug progress.
		func save_data_progress (fname: String, progress: int, error) -> void:
			# No errors detected.
			if error == null: print (("Saving Progress of [" + fname + "]: " + str (progress)));
			# Error detected.
			else: printerr (error.message);
		# Called when the node enters the scene tree for the first time.
		func _ready ():
			# These data will be save into a file.
			var data: Dictionary = {
				a = 15.256,
				b = 9.255,
				c = -456,
				f = false,
				name = MegaAssets.name_generation (5, 7, 3),
				position = {
					x = -55.1255,
					y = -814.34,
					z = 0.75,
					basis = {
						x = Vector3.UP,
						y = Vector3.DOWN,
						z = Vector3.LEFT,
						w = Vector3.RIGHT
					}
				}
			}
			# Let's serialize some data.
			MegaAssets.serialize (data, "res://save_game.dat", self, "abcdefghijk", 				
				MegaAssets.SecurityMethod.GODOT, MegaAssets.SecurityLevel.NORMAL, {
				method = "save_data_progress ()"
			}, MegaAssets.Checksum.NONE);
	\end{lstlisting}
	% Static Dictionary deserialize () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Dictionary} \textcolor{blue}{deserialize} 
		(path, obj, key = '', mhd = 7, level = 1, call = \{\}, check = 0)]: \\Charge un fichier de
		sauvegarde généré avec la function \textit{\textcolor{blue}{\textit{serialize ()}}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Où se trouve le fichier à chargé ?
			\item [>> \textbf{\textcolor{darkgreen}{String} key}:] Quel était le mot de passe utilisé dans 
			la sauvegarde des données ?
			\item [>> \textbf{\textcolor{darkgreen}{Node} obj}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{int} mhd}:] Quelle était la méthode utilisée pour sécuriser 
			les données ? Les méthodes prises en charge sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.NONE} ou \textcolor{blue}{0}}:] 
				Aucune sécurité ne sera appliquée au cours de la sauvegarde des données.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.AES} ou \textcolor{blue}{1}}:] 
				Chiffrement avec la méthode \textit{\textcolor{gray}{AES}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.ARCFOUR} ou \textcolor{blue}
				{2}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{ARCFOUR}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.CHACHA} ou \textcolor{blue}
				{3}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{CHACHA}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.BINARY} ou \textcolor{blue}
				{4}}:] Codage en \textit{\textcolor{gray}{Binaire}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.HEXADECIMAL} ou 
				\textcolor{blue}{5}}:] Codage en \textit{\textcolor{gray}{Hexadécimal}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.OCTAL} ou \textcolor{blue}
				{6}}:] Codage en \textit{\textcolor{gray}{Octal}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.GODOT} ou \textcolor{blue}
				{7}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{GODOT}}.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{int} level}:] Quel était le niveau de sécurité utilisé dans la 
			sauvegarde des données ? Les niveaux de sécurité prises en charge sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.SIMPLE} ou \textcolor{blue}
				{0}}:] Simple niveau de sécurité.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.NORMAL} ou \textcolor{blue}
				{1}}:] Niveau de sécurité normal.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.ADVANCED} ou \textcolor{blue}
				{2}}:] Niveau de sécurité avancé.
			\end{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} call}:] Contient des informations sur la
			méthode à exécutée au cours du chargement d'un fichier. Ce dictionaire supporte les clés
			suivantes:
			\begin{itemize}
			   \newpage \item[• \textbf{\textcolor{darkgreen}{String | NodePath} source}:] Contient
			   l'addresse de la méthode à ciblée. La présence de cette clé n'est pas obligatoire. Dans ce
			   cas, on considéra que la méthode référée se trouve sur celle se trouvant dans le paramètre
			   \textit{\textcolor{gray}{obj}}.
			   \item[• \textbf{\textcolor{darkgreen}{String} method}:] Contient le nom de la méthode à 
			   exécutée. L'utilisation de cette clé est obligatoire.
			\end{itemize}
			Notez que la méthode à exécutée doit possédée cinq (05) paramètres à savoir:
			\begin{itemize}
				\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Contiendra le chemin pointant vers
				le fichier en cours de chargement.
				\item [>> \textbf{\textcolor{red}{bool} is\_loading}:] Le fichier actuelle est-il réelement 
				en cours de chargement ?
				\item [>> \textbf{\textcolor{red}{int} progress}:] Contiendra le nombre d'élément(s) déjà
				chargé(s) en mémoire.
				\item [>> \textbf{\textcolor{darkgreen}{Dictionary} result}:] Contiendra l'ensemble des
				données chargées à partir du fichier en \\question.
				\item [>> \textbf{\textcolor{darkgreen}{Variant} error}:] Contiendra l'erreur déclenchée au
				cours du chargement des données. Ce \\paramètre vous renvoyera un dictionaire contenant les
				clés: \textit{\textcolor{gray}{message, code}} et \textit{\textcolor{gray}{type}} ou nulle
				si aucune erreur ne s'est levée durant la sauvegarde des données.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{int} check}:] Quelle était la méthode de chiffrement utilisée
			pour générer le checksum du fichier de sauvegarde ? Les méthodes disponibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Checksum.NONE} ou \textcolor{blue}{0}}:] Aucun 
				checksum ne sera générer.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Checksum.MD5} ou \textcolor{blue}{1}}:] 
				Chiffrement avec la méthode MD5.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Checksum.SHA256} ou \textcolor{blue}{2}}:] 
				Chiffrement avec la méthode SHA256.\\
			\end{itemize}
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Load data debug progress.
		func load_data_progress (fname: String, is_loading: bool, progress, result, error) -> void:
			# No errors detected.
			if error == null:
				# Is it loading ?
				if is_loading: print (("Loading Progress of [" + fname + "]: " + str (progress)));
				# Otherwise.
				else:
					# Warn the user.
					print ("Loading data successfuly !");
					# Show how many element(s) is loaded in memory.
					print (str (progress) + " data have been loaded in computer memory.");
					# Show all loaded data.
					print ("Data: ", JSON.print (result, "\t"));
			# Error detected.
			else: printerr (error.message);
		# Called when the node enters the scene tree for the first time.
		func _ready ():
			# Let's deserialize the saved data previewsly.
			MegaAssets.deserialize ("res://save_game.dat", self, "abcdefghijk", 	
				MegaAssets.SecurityMethod.GODOT, MegaAssets.SecurityLevel.SIMPLE, {
				method = "load_data_progress ()"
			}, MegaAssets.Checksum.NONE);
	\end{lstlisting}
	% Static Color generate_color () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Color} \textcolor{blue}{generate\_color} 
		(use\_alpha = false):] Génère de façon aléatoire une coleur en \\suivant la méthode RGBA.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{bool} use\_alpha}:] La génération des couleurs doit-elle 
			prendre en charge la transparence ?\\
		\end{itemize}
	\end{description}
	% Static Array get_nodes () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Array} \textcolor{blue}{get\_nodes} 
		(nodes\_paths, object, reversed = false):] Renvoie un ou plusieurs noeud à partir de leur chemins 
		d'accès.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{PoolStringArray} nodes\_paths}:] Contient les chemins en 
			chaîne de caractères des noeuds ciblés.
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{bool} reversed}:] Voulez-vous inverser le sens du traitement à 
			éffectué ?\\
		\end{itemize}
	\end{description}
	% Static void add_children () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{add\_children} (nodes, other, object, 
		reversed = false, delay = 0.0, interval = 0.0):] Ajoute un ou plusieurs noeud(s) à un autre noeud. 
		Le noeud ajouté devient ainsi l'enfant de \textit{\textcolor{gray}{other}}. Notez que le noeud à 
		ajouté ne doit pas avoir au par avant un parent.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{PoolStringArray | String | NodePath} nodes}:] Contient 
			le(s) chemin(s) de(s) noeud(s) que l'on veut ajouté(s).
			\item [>> \textbf{\textcolor{darkgreen}{String | NodePath} other}:] Contient le chemin du future 
			parent du/des noeud(s) à ajouté(s).
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{bool} reversed}:] Voulez-vous inverser le sens du traitement à 
			éffectué ?
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'ajout ?
			\item [>> \textbf{\textcolor{red}{float} interval}:] Quel est le délai avant chaque ajout ?\\
		\end{itemize}
	\end{description}
	% Static PoolStringArray | String name_generation () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray | String} \textcolor{blue}
		{name\_generation} (smin = 3, smax = 7, count: int = 1)]: \\Génère de façon aléatoire un ou 
		plusieurs nom(s). Notez que si la valeur du paramètre \textit{\textcolor{gray}{count}} est 
		inférieure ou égale à zéro, vous aurez une valeur nulle.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} smin}:] Contient la taille minimale du/des nom(s) à 
			généré(s).
			\item [>> \textbf{\textcolor{red}{int} smax}:] Contient la taille maximale du/des nom(s) à 
			généré(s).
			\item [>> \textbf{\textcolor{red}{int} count}:] Combien de nom(s) voulez-vous généré(s) ?\\
		\end{itemize}
	\end{description}
	% Static void save_file_config () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{save\_file\_config} (data, path, object, key 
		= '', security = 0, call = \{\}, delay = 0.0)]: Sauvegarde un dictionaire dans un fichier de 
		configurations. Notez que le fichier de \\configurations doit obligatoirement être au format (.cfg).
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} data}:] Contient toutes les données qui 
			seront sauvegardées.
			\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Où voulez-vous créer le fichier de 
			sauvegarde ?
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{darkgreen}{String} key}:] Quel est le mot de passe des données ?
			\item [>> \textbf{\textcolor{red}{int} security}:] Quel niveau de sécurité voulez-vous utiliser 
			? Les niveaux de sécurité prises en charge sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.SIMPLE} ou \textcolor{blue}
				{0}}:] Simple niveau de sécurité.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.NORMAL} ou \textcolor{blue}
				{1}}:] Niveau de sécurité normal.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.ADVANCED} ou \textcolor{blue}
				{2}}:] Niveau de sécurité avancé.
			\end{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} call}:] Contient des informations sur la
			méthode à exécutée au cours de la sauvegarde d'un fichier. Ce dictionaire supporte les clés
			suivantes:
			\begin{itemize}
			   \item[• \textbf{\textcolor{darkgreen}{String | NodePath} source}:] Contient l'addresse de la
			   méthode à ciblée. La présence de cette clé n'est pas obligatoire. Dans ce cas, on considéra
			   que la méthode référée se trouve sur celle se trouvant dans le paramètre
			   \textit{\textcolor{gray}{object}}.
			   \item[• \textbf{\textcolor{darkgreen}{String} method}:] Contient le nom de la méthode à
			   exécutée. L'utilisation de cette clé est obligatoire.
			\end{itemize}
			Notez que la méthode à exécutée doit possédée trois (03) paramètres à savoir:
			\begin{itemize}
				\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Contiendra le chemin pointant vers
				le fichier en cours de sauvegarde.
				\item [>> \textbf{\textcolor{red}{int} progress}:] Contiendra la progression actuelle de
				fichier en cours de sauvegarde.
				\item [>> \textbf{\textcolor{darkgreen}{Variant} error}:] Contiendra l'erreur déclenchée au
				cours de la sauvegarde des données. Ce \\paramètre vous renvoyera un dictionaire contenant
				les clés: \textit{\textcolor{gray}{message, code}} et \textit{\textcolor{gray}{type}} ou
				nulle si aucune erreur ne s'est levée durant la sauvegarde des données.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant la sauvegarde des 
			données ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Save game configs debug progress.
		func save_configs_progress (fname: String, progress: int, error) -> void:
			# No errors detected.
			if error == null: print (("Saving Progress of [" + fname + "]: " + str (progress)));
			# Error detected.
			else: printerr (error.message);
		# Called when the node enters the scene tree for the first time.
		func _ready ():
			# These data will be save into a file.
			var data: Dictionary = {
				bases = {
					a = 15.256,
					b = 9.255,
					c = -456,
					f = false,
					name = MegaAssets.name_generation (5, 7, 3)
				},
				position = {
					x = -55.1255,
					y = -814.34,
					z = 0.75,
					basis = {
						x = Vector3.UP,
						y = Vector3.DOWN,
						z = Vector3.LEFT,
						w = Vector3.RIGHT
					}
				}
			}
			# Let's save a game configurations data.
			MegaAssets.save_config_file (data, "res://game_configs.cfg", self, "abcdefghijk", 		
				MegaAssets.SecurityLevel.NORMAL, {
				method = "save_configs_progress ()"
			});
	\end{lstlisting}
	% Static Dictionary load_file_config () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Dictionary} \textcolor{blue}
		{load\_file\_config} (path, object, key = '', security = 0, call = \{\}):] Charge un fichier de
		configurations. Notez que le fichier de configurations doit obligatoirement être au format (.cfg). 
		Assurez-vous que le fichier à lire est été créé au préalablement avec la fonction \textcolor{blue}
		{\textit{save\_file\_config ()}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Où se trouve le fichier à chargé ?
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{darkgreen}{String} key}:] Quel était le mot de passe utilisé dans 
			la sauvegarde des données ?
			\item [>> \textbf{\textcolor{red}{int} security}:] Quel était le niveau de sécurité utilisé dans 
			la sauvegarde des données ? Les \\niveaux de sécurité prises en charge sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.SIMPLE} ou \textcolor{blue}
				{0}}:] Simple niveau de sécurité.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.NORMAL} ou \textcolor{blue}
				{1}}:] Niveau de sécurité normal.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.ADVANCED} ou \textcolor{blue}
				{2}}:] Niveau de sécurité avancé.
			\end{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} call}:] Contient des informations sur la
			méthode à exécutée au cours du chargement d'un fichier. Ce dictionaire supporte les clés
			suivantes:
			\begin{itemize}
			   \item[• \textbf{\textcolor{darkgreen}{String | NodePath} source}:] Contient l'addresse de la
			   méthode à ciblée. La présence de cette clé n'est pas obligatoire. Dans ce cas, on considéra
			   que la méthode référée se trouve sur celle se trouvant dans le paramètre
			   \textit{\textcolor{gray}{object}}.
			   \item[• \textbf{\textcolor{darkgreen}{String} method}:] Contient le nom de la méthode à 
			   exécutée. L'utilisation de cette clé est obligatoire.
			\end{itemize}
			Notez que la méthode à exécutée doit possédée quatres (04) paramètres à savoir:
			\begin{itemize}
				\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Contiendra le chemin pointant vers
				le fichier en cours de chargement.
				\item [>> \textbf{\textcolor{red}{int} progress}:] Contiendra la progression actuelle du
				chargement.
				\item [>> \textbf{\textcolor{darkgreen}{Dictionary} result}:] Contiendra l'ensemble des
				données chargées à partir du fichier en \\question.
				\item [>> \textbf{\textcolor{darkgreen}{Variant} error}:] Contiendra l'erreur déclenchée au
				cours du chargement des données. Ce \\paramètre vous renvoyera un dictionaire contenant les
				clés: \textit{\textcolor{gray}{message, code}} et \textit{\textcolor{gray}{type}} ou nulle
				si aucune erreur ne s'est levée durant la sauvegarde des données.\\
			\end{itemize}
		\end{itemize}
	\end{description}
	\newpage \textbf{Code: GDScript}
	\begin{lstlisting}
		# Load game configs debug progress.
		func load_configs_progress (fname: String, progress: int, result, error) -> void:
			# No errors detected.
			if error == null:
				# Show loading progress.
				print (("Loading Progress of [" + fname + "]: " + str (progress)));
				# The loading is it complete ?
				if progress == 100:
					# Warn the user.
					print ("Loading configs successfuly !");
					# Show all loaded data.
					print ("Data: ", JSON.print (result, "\t"));
			# Error detected.
			else: printerr (error.message);
		# Called when the node enters the scene tree for the first time.
		func _ready ():
			# Let's load a game configurations data.
			MegaAssets.load_config_file ("res://game_configs.cfg", self, "abcdefghijk", 			
				MegaAssets.SecurityLevel.NORMAL, {
				method = "load_configs_progress ()"
			});
	\end{lstlisting}
	% Static void create_folders_from () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{create\_folders\_from} (path, object, delay = 
		0.0):] Cré les dossiers néccessaires à \\l'accès d'un fichier.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Contient un chemin pointant vers un 
			fichier quelconque.
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant la création des 
			dossiers ?\\
		\end{itemize}
	\end{description}
	% Static Dictionary any_to_dic () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Dictionary} \textcolor{blue}{any\_to\_dic} 
		(input, reversed = false):] Converti une entrée donnée en \\dictionnaire.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} input}:] Contient une valeur quelconque.
			\item [>> \textbf{\textcolor{red}{bool} reversed}:] Voulez-vous inverser le sens du traitement à 
			éffectué ?\\
		\end{itemize}
	\end{description}
	% Static Array any_to_array () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Array} \textcolor{blue}{any\_to\_array} 
		(input, dic\_property = 1):] Converti une entrée donnée en tableau.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} input}:] Contient une valeur quelconque.
			\item [>> \textbf{\textcolor{red}{int} dic\_property}:] Quelle propriété du dictionaire sera 
			convert en tableau. Les valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.DictionaryProperty.KEYS} ou \textcolor{blue}
				{0}}:] Cible les clés du dictionaire.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.DictionaryProperty.VALUES} ou \textcolor{blue}
				{1}}:] Cible les valeurs des clés du dictionaire.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.DictionaryProperty.BOTH} ou \textcolor{blue}
				{2}}:] Cible les clés ainsi que leur valeur du \\dictionaire.
			\end{itemize}
			Ce paramètre est à utilisé uniquement lorsque l'entrée est un dictionaire.\\
		\end{itemize}
	\end{description}
	% Static void raise_event () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{raise\_event} (data, scope, mode = 1,
		recursive = true, delay = 0.0):] Déclenche un ou plusieurs événement(s) à la fois.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Array} actions}:] Tableau de dictionnaires gérant les
			configurations liées au différents \\événements que l'on veut prendre en charge. Le(s)
			dictionnaire(s) issu(s) de ce tableau, \\supportent les clés suivantes:
		    \begin{itemize}
			    \item[• \textbf{\textcolor{darkgreen}{String} event}:] Contient le nom de l'événement à
			    déclenché.
			    \item[• \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'appel de
			    l'événement en question.
			    \item[• \textbf{\textcolor{darkgreen}{Array} params}:] Contient les valeurs des différents 
			    paramètres de l'événement en question.
			\end{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} scope}:] Contient le noeud à partir duquel le(s)
			événement(s) sera/ont déclenché(s).
			\item [>> \textbf{\textcolor{red}{int} mode}:] Contient la portée de l'événement en question. 
			Les valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.WornEvents.NONE} ou \textcolor{blue}{0}}:] 
				Pas de porté.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.WornEvents.CHILDREN\_ONLY} ou 
				\textcolor{blue}{1}}:] Uniquement les enfants recevront \\l'événement(s).
				\item [-> \textbf{\textcolor{gray}{MegaAssets.WornEvents.PARENTS\_ONLY} ou \textcolor{blue}
				{2}}:] Uniquement le(s) parent(s) recevra/ont \\l'événement(s).
				\item [-> \textbf{\textcolor{gray}{MegaAssets.WornEvents.ALL} ou \textcolor{blue}{2}}:] Le 
				parent ainsi que les enfants recevront \\l'événement(s).
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{bool} recursive}:] La portée de(s) événement(s) sera t-elle
			récursive ?
			\item [>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant le déclenchement 
			?\\
		\end{itemize}
	\end{description}
	% Static String | PoolIntArray get_time_from () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String | PoolIntArray} \textcolor{blue}
		{get\_time\_from} (seconds, divider = ':', parse = false):] Renvoie \\le temps correspondant au 
		seconds données au format \textit{\textcolor{gray}{HH:MM:SS}}.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} seconds}:] Contient le temps en seconds.
			\item [>> \textbf{\textcolor{darkgreen}{String} divider}:] Contient le séparateur à utilisé.
			\item [>> \textbf{\textcolor{red}{bool} parse}:] L'activation de ce paramètre obligera la 
			fonction à renvoyé un tableau constitué de trois entiers, dont le premier élément contient 
			l'heure, le second: la minute et le dernier: la seconde.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called when the node enters the scene tree for the first time.
		func _ready ():
			# Let's get the real time of 7255 secondes.
			MegaAssets.get_time_from (7255); # Return 02h:00min:55s
	\end{lstlisting}
	% Static String get_type () method description.
	\newpage \begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{get\_type} (input):] 
		Renvoie le type d'un objet en chaîne de caractères.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient la valeur d'un type
			quelconque.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			print (MegaAssets.get_type (125)); # Return "int"
			print (MegaAssets.get_type ("Mother")); # Return "String"
			print (MegaAssets.get_type (false)); # Return "bool"
			print (MegaAssets.get_type (15.36)); # Return "float"
			print (MegaAssets.get_type (["false", 12, Vector2.UP])); # Return "Array"
			print (MegaAssets.get_type ({name = "Mother"})); # Return "Dictionary"
			print (MegaAssets.get_type (null)); # Return "Nil"
	\end{lstlisting}
	% Static bool is_array () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_array} (input):] Détermine si une entrée 
		est un tableau.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient la valeur d'un type 
			quelconque.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			print (MegaAssets.is_array (125)); # Return false
			print (MegaAssets.is_arry (PoolStringArray (["s", "b"]))); # Return true
			print (MegaAssets.is_arry (PoolByteArray ([45, 59, 93]))); # Return true
			print (MegaAssets.is_array (PoolIntArray ([96, -74, 3]))); # Return true
			print (MegaAssets.is_array (["false", 12, Vector2.UP])); # Return true
			print (MegaAssets.is_array (PoolRealArray ([74.36, 95.31]))); # Return true
			print (MegaAssets.is_array (null)); # Return false
	\end{lstlisting}
	% Static String | PoolStringArray file_find () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{file\_find} (inp, 
		path, key = '', case = false, count = 1, mhd = 5, level = 1)]: \\Renvoie le ou les lignes contenant 
		la valeur à chercher dans un fichier.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String | PoolStringArray} inp}:] Que voulez-vous 
			chercher ?
			\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Où se trouve le fichier en question ?
			\item [>> \textbf{\textcolor{darkgreen}{String} key}:] Le fichier à ouvrir est-il crypté ?
			\item [>> \textbf{\textcolor{red}{bool} case}:] La recherche doit-elle s'éffectuée en ignorant 
			la casse ?
			\item [>> \textbf{\textcolor{red}{int} count}:] Combien de résultats seront renvoyés ? Notez 
			qu'une valeur nulle donnera un \\résultat nulle et une valeur négative obligera la function à 
			renvoyée tous les résultats trouvés au cours de la rechercher.
			\item [>> \textbf{\textcolor{red}{int} mhd}:] Quelle était la méthode utilisée pour sécuriser 
			le fichier ? Les méthodes prises en charge sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.NONE} ou \textcolor{blue}{0}}:] 
				Aucune sécurité ne sera appliquée au cours de la sauvegarde des données.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.AES} ou \textcolor{blue}{1}}:] 
				Chiffrement avec la méthode \textit{\textcolor{gray}{AES}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.ARCFOUR} ou \textcolor{blue}
				{2}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{ARCFOUR}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.CHACHA} ou \textcolor{blue}
				{3}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{CHACHA}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.BINARY} ou \textcolor{blue}
				{4}}:] Codage en \textit{\textcolor{gray}{Binaire}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.HEXADECIMAL} ou 
				\textcolor{blue}{5}}:] Codage en \textit{\textcolor{gray}{Hexadécimal}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.OCTAL} ou \textcolor{blue}
				{6}}:] Codage en \textit{\textcolor{gray}{Octal}}.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityMethod.GODOT} ou \textcolor{blue}
				{7}}:] Chiffrement avec la méthode \textit{\textcolor{gray}{GODOT}}.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{int} level}:] Quel était le niveau de sécurité utilisé pour 
			sécuriser le fichier ? Les niveaux de \\sécurité prises en charge sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.SIMPLE} ou \textcolor{blue}
				{0}}:] Simple niveau de sécurité.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.NORMAL} ou \textcolor{blue}
				{1}}:] Niveau de sécurité normal.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.SecurityLevel.ADVANCED} ou \textcolor{blue}
				{2}}:] Niveau de sécurité avancé.\\
			\end{itemize}
		\end{itemize}
	\end{description}
	% Static Int | PoolIntArray get_index_of () method description.
	\begin{description}
		\item [+ \textcolor{red}{static int} | \textcolor{darkgreen}{PoolIntArray} \textcolor{blue}
		{get\_index\_of} (datum, input, reversed = false, recursive = true)]: \\Renvoie l'index d'un élément 
		contenu une liste ou un dictionaire.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Variant} datum}:] Contient l'élément dont-on veut
			récupéré l'index de position.
			\item [>> \textbf{\textcolor{darkgreen}{Array | Dictionary | String} data}:] Contient le 
			conteneur de l'élément ciblé.
			\item [>> \textbf{\textcolor{red}{bool} reversed}:] Voulez-vous inverser le sens du traitement à 
			éffectué ?
			\item [>> \textbf{\textcolor{red}{bool} recursive}:] Trouver la position de l'élément en 
			utilisant un programme récursive ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			print (MegaAssets.get_index_of (5, 125)); # Return -1
			print (MegaAssets.get_index_of ('h', "Mother")); # Return 3
			print (MegaAssets.get_index_of (12, ["false", 12, Vector2.UP])); # Return 1
			print (MegaAssets.get_index_of ("position", {name = "Mother",
				position = Vector3.DOWN})); # Return 1
	\end{lstlisting}
	% Static Variant parse_date () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{parse\_date} 
		(format = "dd-mm-yy", date, to\_letter = false, parse = false)]: \\Parse une date. Si aucune date 
		n'est renseignée dans le paramètre \textit{\textcolor{gray}{date}}, la date actuelle du sytème 
		d'exploitation sera utilisée.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} format}:] Quel format de date voulez-vous ? 
			Notez que le format de votre date doit \\contenir les caractères: \textcolor{gray}{d:} pour 
			afficher le jour, \textcolor{gray}{m:} pour afficher le mois et \textcolor{gray}{y:} pour 
			afficher l'année. Exemple: \textcolor{gray}{"dd-mm-yy", "yy/mm/dd", "mm:yy", "dd yy"}, etc...
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} date}:] Contient les données relatives à une 
			date. Ce dictionaire supporte les clés suivant:
			\begin{itemize}
				\item[>> \textbf{\textcolor{red}{int} day = \textcolor{blue}{1}}:] Contient le jour.
				\item[>> \textbf{\textcolor{red}{int} month = \textcolor{blue}{1}}:] Contient le mois.
				\item[>> \textbf{\textcolor{red}{int} year = \textcolor{blue}{1996}}:] Contient l'année.
			\end{itemize}
			\item [>> \textbf{\textcolor{red}{bool} to\_letter}:] Voulez-vous avoir le nom du mois 
			correspondant à son numéro ?
			\item [>> \textbf{\textcolor{red}{bool} parse}:] Obligera la function à retourné un dictionaire
			contenant en plus des clés de base, une clé de plus appelée: \textit{\textcolor{gray}
			{bixestile}}. Cette clé détermine si l'année référencée est bixestile ou non. Elle contient une
			valeur booléenne.\\
		\end{itemize}
	\end{description}
	% Static Variant run_slot () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{run\_slot} (data, 
		object)]: Exécute tous les actions exigées par le développeur à \\partir d'un dictionaire.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Dictionary} data}:] Contient tous les configurations 
			relatives à un flux d'exécution. L'utilisation de ce paramètre est déjà décrite au niveau des
			bases du framework. Précisement le sujet \\portant sur l'utilisation de la propriété 
			\textcolor{gray}{EventsBindings} (la section des actions liées à un \\événement).
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		var force = -500;
		var property = "text";
		func parser4 (data = 123): return data;
		# Called when the node enters the scene tree for the first time.
		func _ready ():
			MegaAssets.run_slot ({
				"action": "property",
				"value": {
					"source": self,
					"action": "parser4()",
					"params": ["?force"]
				}
			});
			print (property); # Will return -500
	\end{lstlisting}
	% Static void run_slots () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{run\_slots} (data, object, delay = 0.0)]: 
		Exécute tous les actions exigées par le \\développeur à partir d'un tableau de dictionaire.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Array | Dictionary} data}:] Contient toutes les 
			configurations relatives à un ou plusieurs flux d'exécution(s). L'utilisation de ce paramètre 
			est déjà décrite au niveau des bases du framework. Précisement le sujet portant sur
			l'utilisation de la propriété \textcolor{gray}{EventsBindings} (la section des actions liées à 
			un événement).
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant les exécutions ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		var force = -500;
		var property = "text";
		var dic = {"x": 96};
		func parser (): print ("dddd");
		func parser4 (data = 123): return data;
		# Called when the node enters the scene tree for the first time.
		func _ready ():
			MegaAssets.run_slots ([
				{"source": self, "action": "property", "value": "?force"},
				{"action": "parser()"},
				{"action": "dic", "value": {"source": "WorldEnvironment", "action": "is_dont_destroy()"}},
				{"action": "force", "value": "?parser4()", "params": ["?property"]}
			]);
			print (property); # Will return -500
	\end{lstlisting}
	% Static float get_filtered_joy_axis () method description.
	\begin{description}
		\item [+ \textcolor{red}{static float} \textcolor{blue}{get\_filtered\_joy\_axis} (axis)]: Renvoie 
		la forme filtrée d'un axe d'une manette.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{float} axis}:] Contient la valeur d'une touche d'axe de la 
			manette.\\
		\end{itemize}
	\end{description}
	% Static bool is_key_or_axis_pressed () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_key\_or\_axis\_pressed} (key\_event,
		device = 0)]: Détermine si une touche est \\appuyée ou nom. Cette méthode supporte également les 
		touches d'axes.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{InputEvent} key\_event}:] Contient une touche 
			d'événement.
			\item[>> \textbf{\textcolor{red}{int} device}:] Quelle manette écoutée ? N'utilisez ce paramètre 
			que si le contrôleur est une \\manette.\\
		\end{itemize}
	\end{description}
	% Static PoolStringArray get_connected_controllers_names () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} | \textcolor{darkgreen}{PoolStringArray} \textcolor{blue}
		{get\_connected\_controllers\_names} ()]: Renvoie les noms de tous les contrôleurs connectés à 
		l'ordinateur.\\
	\end{description}
	% Static String get_input_key_translation () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}
		{get\_input\_key\_translation} (key\_event, object, device = 0, path = "...")]: Renvoie le nom
		correspondant à la touche appuyée en fonction du contôleur détecté. Notez que cela ne marche pas à 
		tout moment car cela dépend du contôleur utilisé. Plus précisement au niveau de la manette. En cas 
		d'échec de traduction, une valeur universelle sera renvoyée. Cette valeur \\universelle n'est rien 
		d'autre que le nom que donne Godot à ses touches.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{InputEvent} key\_event}:] Contient une touche 
			d'événement.
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item[>> \textbf{\textcolor{red}{int} device}:] Quelle manette écoutée ? N'utilisez ce paramètre 
			que si le contrôleur est une \\manette.
			\item[>> \textbf{\textcolor{darkgreen}{String} path}:] Contient le chemin pointant vers le 
			fichier de configuration (.cfg) des manettes non reconnu par cette methode. Pour editer ce
			ficher, vous devez suivre la nomenclature \\suivante:\\
			\{gamepads\}\\
			NomDeLaManette1 = CategoryDeLaManette1 (Playstation, Xbox, Nitendo, etc...)\\
			NomDeLaManette2 = CategoryDeLaManette2 (Playstation, Xbox, Nitendo, etc...)\\
			...\\
			NomDeLaManetteN = CategoryDeLaManetteN (Playstation, Xbox, Nitendo, etc...)\\
			Les alcolades autour de \textit{\textcolor{gray}{gamepads}} seront remplacés par des crochets.
			Comme vous pouvez le constaté, un chemin par défaut est donné. Notez que des catégories de
			manettes ont été déjà renseignés dans le fichier de configuration que cible cette méthode.
			La valeur par défaut de ce paramètre est: \textit{\textcolor{gray}{res://addons/mega\_assets/
			nodes/base/mega\_assets/gamepads.cfg}}.\\
		\end{itemize}
	\end{description}
	% Static bool is_button () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_button} (key\_event)]: Détermine si la 
		touche appuyée est un bouton ou nom.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{InputEvent} key\_event}:] Contient une touche 
			d'événement.\\
		\end{itemize}
	\end{description}
	% Static bool is_axis () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_axis} (key\_event)]: Détermine si la 
		touche appuyée est un axe ou nom.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{InputEvent} key\_event}:] Contient une touche 
			d'événement.\\
		\end{itemize}
	\end{description}
	% Static String get_keycode_string () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}
		{get\_keycode\_string} (key\_event, device = 0, mask = false)]: Renvoie le code \\correspondant à la 
		touche appuyée sous format de chaîne de caractères. Notez que ce qui est renvoyé n'est pas le code 
		ASCII réel de la touche.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{InputEvent} key\_event}:] Contient une touche 
			d'événement.
			\item[>> \textbf{\textcolor{red}{int} device}:] Quelle manette écoutée ? N'utilisez ce paramètre 
			que si le contrôleur est une \\manette.
			\item[>> \textbf{\textcolor{red}{int} mask}:] Voulez-vous utiliser l'option de masquage pour 
			renvoyer le code des touches de la souris ? N'utilisez ce paramètre que si le contrôleur est une 
			souris.\\
		\end{itemize}
	\end{description}
	% Void apply_root_motion () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{apply\_root\_motion} (anim, node, delta, gravity = 
		9.8, delay = 0.0)]: Déplace un noeud de type
		\href{https://docs.godotengine.org/fr/stable/classes/class_kinematicbody.html}
		{\textit{\textcolor{darkgreen}{KinematicBody}}} à partir des transformations du bone racine d'un 
		squelette d'animation.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Node | String | NodePath} anim}:] Contient l'instance 
			d'un noeud de type
			\href{https://docs.godotengine.org/fr/stable/classes/class_animationtree.html}
			{\textit{\textcolor{darkgreen}{AnimationTree}}}.
			\item[>> \textbf{\textcolor{darkgreen}{Node | String | NodePath} node}:] Contient l'instance 
			d'un noeud de type
			\href{https://docs.godotengine.org/fr/stable/classes/class_kinematicbody.html}
			{\textit{\textcolor{darkgreen}{KinematicBody}}}.
			\item[>> \textbf{\textcolor{red}{float} delta}:] Contient le temps écoulé depuis la dernière 
			trame du jeu.
			\item[>> \textbf{\textcolor{red}{float} gravity}:] Quelle sera la force gravitationnelle à 
			appliquée sur l'objet affecté par les \\transformations du bone racine ?
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant la mise à jour des
			transformations de l'objet ciblé ?\\
		\end{itemize}
	\end{description}
	% Static void apply_camera_effect () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{apply\_camera\_effect} (pvt, eft, obj, lyt = 
		0, fus = 0, delay = 0.0)]: Applique un \\éffet de caméra sur l'objet sélectionné.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{String | NodePath} pvt}:] Contient l'instance d'un noeud
			de type \href{https://docs.godotengine.org/fr/stable/classes/class_sprite.html}
			{\textit{\textcolor{darkgreen}{Sprite}}} ou
			\href{https://docs.godotengine.org/fr/stable/classes/class_texturerect.html}
			{\textit{\textcolor{darkgreen}{TextureRect}}}.
			\item[>> \textbf{\textcolor{red}{int} eft}:] Quel éffet voulez-vous appliqué ? Les valeurs
			possibles sont celles définient au sein du module \textit{\textcolor{darkgreen}
			{CameraEffectsFx}} (Au niveau du champ \textit{\textcolor{gray}{Effect}}).
			\item [>> \textbf{\textcolor{darkgreen}{Node} obj}:] Quel noeud sera considéré pour éffectuer 
			les différentes opérations ?
			\item[>> \textbf{\textcolor{red}{int} lyt}:] Voulez-vous donner une disposition à votre éffet ?
			Les valeurs possibles sont celles \\définient au sein du module \textit{\textcolor{darkgreen}
			{CameraEffectsFx}} (Au niveau du champ \textit{\textcolor{gray}{Layout}}).
			\item[>> \textbf{\textcolor{red}{int} fus}:] Shouhaitez-vous modifier de façon dynamique la 
			taille de votre éffet ? Les \\valeurs possibles sont celles définient au sein du module 
			\textit{\textcolor{darkgreen}{CameraEffectsFx}} (Au niveau du champ \textit{\textcolor{gray}
			{FullScreen}}).
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'application de 
			l'éffet en question ?\\
		\end{itemize}
	\end{description}
	% Void apply_occlusion_culling () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{apply\_occlusion\_culling} (cam, nodes, delta, acy = 
		1000.0, scans = 10.0, delay = 0.0)]: Utilise une caméra pour déterminer si les objets prises en
		charge vont s'afficher ou non. Cette \\méthode est très utile pour l'optimisation de la mémoire 
		graphique. Notez que le(s) objet(s) que vous choisirez doivent des instances des types suivants:
		\href{https://docs.godotengine.org/fr/stable/classes/class_kinematicbody.html}
		{\textit{\textcolor{darkgreen}{KinematicBody}}},
		\href{https://docs.godotengine.org/fr/stable/classes/class_rigidbody.html}
		{\textit{\textcolor{darkgreen}{RigidBody}}},
		\href{https://docs.godotengine.org/fr/stable/classes/class_area.html}
		{\textit{\textcolor{darkgreen}{Area}}},
		\href{https://docs.godotengine.org/fr/stable/classes/class_staticbody.html}
		{\textit{\textcolor{darkgreen}{\\StaticBody}}},
		\href{https://docs.godotengine.org/fr/stable/classes/class_softbody.html}
		{\textit{\textcolor{darkgreen}{SoftBody}}}.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Node | String | NodePath} cam}:] Contient l'instance 
			d'un noeud de type
			\href{https://docs.godotengine.org/fr/stable/classes/class_camera.html}
			{\textit{\textcolor{darkgreen}{Camera}}}.
			\item[>> \textbf{\textcolor{darkgreen}{Array} nodes}:] Contient les noeuds sous l'emprise de
			l'occlusion.
			\item[>> \textbf{\textcolor{red}{float} delta}:] Contient le temps écoulé depuis la dernière 
			trame du jeu.
			\item[>> \textbf{\textcolor{red}{float} acy}:] Contient la précision de l'occlusion.
			\item[>> \textbf{\textcolor{red}{float} scans}:] Contient la fréquence du scan à éffectuée par 
			seconde par l'occlusion.
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant le démarrage de
			l'occlusion des noeuds ?\\
		\end{itemize}
	\end{description}
	% Static void apply_std_effect () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{apply\_std\_effect} (pvt, eft, obj, geo =
		true, idx = 0, next = false, delay = 0.0)]: \\Applique un éffet standard à l'objet sélectioné.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{String | NodePath} pvt}:] Contient l'instance 
			d'un noeud de type
			\href{https://docs.godotengine.org/fr/stable/classes/class_geometryinstance.html}
			{\textit{\textcolor{darkgreen}{GeometryInstance}}},
			\href{https://docs.godotengine.org/fr/stable/classes/class_node2d.html}
			{\textit{\textcolor{darkgreen}{Node2D}}} ou
			\href{https://docs.godotengine.org/fr/stable/classes/class_control.html}
			{\textit{\textcolor{darkgreen}{Control}}}.
			\item[>> \textbf{\textcolor{red}{int} eft}:] Quel éffet voulez-vous appliqué ? Les valeurs
			possibles sont celles définient au sein du module \textit{\textcolor{darkgreen}
			{StandardEffectsFx}} (Au niveau du champ \textit{\textcolor{gray}{Effect}}).
			\item [>> \textbf{\textcolor{darkgreen}{Node} obj}:] Quel noeud sera considéré pour éffectuer 
			les différentes opérations ?
			\item[>> \textbf{\textcolor{red}{bool} geo}:] Voulez-vous que l'éffet à appliqué soit mis sur
			la propriété \textit{\textcolor{gray}{material\_override}} ? Notez que la désactivation de cette 
			option ne peut qu'être fait que sur un noeud de type
			\href{https://docs.godotengine.org/fr/stable/classes/class_meshinstance.html}
			{\textit{\textcolor{darkgreen}{MeshInstance}}}.
			\item[>> \textbf{\textcolor{red}{bool} next}:] Voulez-vous que l'éffet à appliqué soit mis sur 
			la valeur de la propriété \textit{\textcolor{gray}{NextPass}} ? Le comportement de cette option 
			est récursive.
			\item[>> \textbf{\textcolor{red}{int} idx}:] Contient l'index de position du matériel qui sera
			affecté par l'éffet. Cette propriété est à utilisée uniquement sur un noeud de type
			\href{https://docs.godotengine.org/fr/stable/classes/class_meshinstance.html}
			{\textit{\textcolor{darkgreen}{MeshInstance}}}.
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'application de 
			l'éffet en question ?\\
		\end{itemize}
	\end{description}
	% Static bool is_range () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_range} (value, minimum, maximum)]: 
		Détermine si une valeur appartient à \\l'intervalle précisé.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{float} value}:] Contient une valeur.
			\item[>> \textbf{\textcolor{red}{float} minimum}:] Contient la valeur minimum de l'intervalle.
			\item[>> \textbf{\textcolor{red}{float} maximum}:] Contient la valeur maximum de l'intervalle.\\
		\end{itemize}
	\end{description}
	\newpage \textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			print (MegaAssets.is_range (125, 25.36, 524.36)); # Return true
			print (MegaAssets.is_range (69, 14.019, 36.216)); # Return false
	\end{lstlisting}
	% Static Transform get_ik_look_at () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Transform} \textcolor{blue}
		{get\_ik\_look\_at} (skn, bme, tar, obj, dir = 2, oft = Vector3.ZERO, fze = 0)]: \\Renvoie la 
		transformation de l'os à partir de la position de sa cible. Cette méthode utilise la fonction
		\href{https://docs.godotengine.org/fr/stable/classes/class_spatial.html#class-spatial-method-look-at}{\textit{\textcolor{blue}{look\_at ()}}} pour suivre l'objet donné.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{String | NodePath} skn}:] Contient l'instance d'un noeud 
			de type \href{https://docs.godotengine.org/fr/stable/classes/class_skeleton.html}
			{\textit{\textcolor{darkgreen}{Skeleton}}}.
			\item[>> \textbf{\textcolor{darkgreen}{String} bme}:] Contient le nom de la section (bone) à 
			ciblée.
			\item[>> \textbf{\textcolor{darkgreen}{String | NodePath} tar}:] Contient l'instance d'un noeud
			de type \href{https://docs.godotengine.org/fr/stable/classes/class_spatial.html}
			{\textit{\textcolor{darkgreen}{Spatial}}}.
			\item [>> \textbf{\textcolor{darkgreen}{Node} obj}:] Quel noeud sera considéré pour éffectuer 
			les différentes opérations ?
			\item[>> \textbf{\textcolor{red}{int} dir}:] Quel axe sera choisi pour pister la cible référée ?
			Les valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.X} ou \textcolor{blue}{1}}:] L'axe des 
				absisses.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.Y} ou \textcolor{blue}{2}}:] L'axe des 
				ordonnés.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.Z} ou \textcolor{blue}{3}}:] L'axe des 
				côtes.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.\_X} ou \textcolor{blue}{4}}:] L'opposé 
				de l'axe des absisses.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.\_Y} ou \textcolor{blue}{5}}:] L'opposé 
				de l'axe des ordonnés.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.\_Z} ou \textcolor{blue}{6}}:] L'opposé 
				de l'axe des côtes.
			\end{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Vector3} oft}:] Contient le décalage de la rotation du 
			bone. Utilisez cet paramètre pour ajuster l'angle de la section si la valeur par défaut ne 
			répond pas à vos attentes.
			\item[>> \textbf{\textcolor{red}{int} fze}:] Quel axe bloqué au cours du pistage ? Les valeurs 
			possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.NONE} ou \textcolor{blue}{0}}:] Aucun 
				blockage.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.X} ou \textcolor{blue}{1}}:] Blockage de 
				l'axe des absisses.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.Y} ou \textcolor{blue}{2}}:] Blockage de 
				l'axe des ordonnés.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.Z} ou \textcolor{blue}{3}}:] Bockage de 
				l'axe des côtes.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.\_X} ou \textcolor{blue}{4}}:] Blockage 
				de l'opposé de l'axe des absisses.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.\_Y} ou \textcolor{blue}{5}}:] Blockage 
				de l'opposé de l'axe des ordonnés.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.\_Z} ou \textcolor{blue}{6}}:] Blockage 
				de l'opposé de l'axe des côtes.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XY} ou \textcolor{blue}{7}}:] Bockage des 
				axes x et y.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XZ} ou \textcolor{blue}{8}}:] Bockage des 
				axes x et z.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.YZ} ou \textcolor{blue}{9}}:] Bockage des 
				axes y et z.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.\_XY} ou \textcolor{blue}{10}}:] Bockage 
				de l'opposé des axes x et y.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.\_XZ} ou \textcolor{blue}{11}}:] Bockage 
				de l'opposé des axes x et z.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.\_YZ} ou \textcolor{blue}{12}}:] Bockage 
				de l'opposé des axes y et z.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XYZ} ou \textcolor{blue}{13}}:] Bockage 
				des axes x, y et z.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.\_XYZ} ou \textcolor{blue}{14}}:] Bockage 
				de l'opposé des axes x, y et z.\\
			\end{itemize}
		\end{itemize}
	\end{description}
	\newpage \textbf{Code: GDScript}
	\begin{lstlisting}
		var bone_name: String = "head";
		# Called every frame. "delta" is the elapsed time since the previous frame.
		func _process (_delta):
			var idx: int = $Armature/Skeleton.find_bone (bone_name);
			var rest: Transform = MegaAssets.get_ik_look_at (
				"Armature/Skeleton", bone_name, "target", self, MegaAssets.Axis.Y,
				Vector3 (0.0, -180.0, 0.0), MegaAssets.Axis.NONE
			);
			$Armature/Skeleton.set_bone_global_pose_override (idx, rest, 1.0, true);
	\end{lstlisting}
	% Void bind_prop () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{\hypertarget{bindprop}{bind\_prop}} (data, delay = 
		0.0)]: Ajoute une propriété dans la liste des propriétés d'un script. N'appelez cette méthode que 
		dans la fonction virtuelle:
		\href{https://docs.godotengine.org/fr/stable/classes/class_object.html#class-object-method-init}
		{\textit{\textcolor{blue}{\_init ()}}}. \\Avant de continuer, vous devez savoirs que les clés 
		suivantes peuvent être manipulées dans \\l'utilisation des clés:
		\textit{\textcolor {gray}{showif, disableif, require, changed, min, max, button, clone et
		notification}}.
		\begin{itemize}
		    \item[>> \textbf{\textcolor{darkgreen}{String} | \textcolor{red}{bool} statement}:] Contient la 
		    déclaration du développeur. Vous avez la possibilité de donné un booléen tout comme une chaîne 
		    de caractères. Si vous donnez une chaîne, alors elle devra remfermer une condition qui est 
		    exactement comme les déclarations que vous faites lorsque vous définissez une condition en 
		    programmation, mais à quelques différences près. \\Exemple:\\
		    \textbf{\textcolor {gray}{"propriete1 > 56 || propriete2 != ?propriete3 and !propriete4"}}\\
		    \textbf{\textcolor {gray}{"methode1() == not option"}}\\
		    \textbf{\textcolor {gray}{"propriete5 <= ?methode2() and propriete4 or !methode1()"}}\\
		    \textbf{\textcolor {gray}{"StringProperty == null"}} => Vérifiera si la chaîne
		    \textit{\textcolor {gray}{StringProperty}} est vide ("").\\
		    Le point d'interrogation signifie que l'on veut aller chercher la valeur que renvoie une autre 
		    propriété ou méthode prédéfinit. Les expressions mathématiques et les appels de méthodes
		    \\paramétrable ne sont pas prises en charge dans une déclaration. Toute fois, si vous voulez
		    \\recupérer la valeur d'une clé ou d'un index de position contenu dans un dictionaire ou tableau 
		    vous devez adopter la nomenclature:
		    \textit{\textcolor {gray}{NomDeLaPropriete.LeNomDeLaCle/IndexDePosition}}. \\Exemple:
		    \textbf{\textcolor {gray}{"tableau1.2 > ?tableau2.0 || dictionaire1.2 != ?dictionaire3.level"}}
		   	\\Cependant, n'utilisé cette clé que si vous manipulez les clés suivantes:
		    \textit{\textcolor {gray}{showif, disableif, clone, require et notification}}.\\
			\item[>> \textbf{\textcolor{darkgreen}{Array | Dictionary} actions}:] Contient les différentes
			configurations sur la manière dont les \\actions seront exécutées à la vérification de certaines 
			conditions. Si vous donnez un tableau, alors celui-ci devra que contenir des dictionaires 
			supportant les mêmes clés que si vous passez un dictionaire ordinaire. Si vous donnez un 
			dictionaire, alors il supportera les clés suivantes:
		    \begin{itemize}
		    	\item[• \textbf{\textcolor{darkgreen}{String} slot}:] Contient le nom de la méthode ou 
		    	propriété à ciblée lorsque les conditions d'exécution sont validées.\\
		    	\newpage \item[• \textbf{\textcolor{darkgreen}{Variant} value}:] Cette clé, est à utilisée 
		    	uniquement lorsque l'action à éffectuée est sur une propriété. Elle contient la valeur à
		    	affectée à la propriété en question, si vous ne passé pas un dictionaire. Dans le cas
		    	contraire, vous serez dans l'obligation de redéfinir la propriété avec toutes les clés que
		    	vous utilisez à la création d'une propriété via la méthode \textit{\textcolor {blue}
		    	{\hyperlink{bindprop}{bind\_prop ()}}}.\\
		    	\item[• \textbf{\textcolor{darkgreen}{Array} params}:] Contient les valeurs des différents 
		    	paramètres de la méthode ciblée. Cette clé, est à utilisée uniquement lorsque l'action à 
		    	éffectuée est sur une méthode. Le \\remplissage de ce tableau, doit respecté l'ordre 
		    	d'alignement des paramètres de la méthode en question. Inutile d'utiliser cette clé, si la 
		    	méthode n'a pas de(s) paramètre(s) ou peut prendre aucun argument(s). Notez que vous avez la 
		    	possibilité de récupérer la valeur d'une autre propriété ou méthode grâce au mots clés 
		    	spécials (\textit{\textcolor {gray}{?NomDeLaPropriete ou \\?NomDeLaMethode()}}). Cette clé 
		    	est uniquement présente sur les clés: \textit{\textcolor {gray}{changed, actions}} et 
		    	\textit{\textcolor {gray}{value}}.\\
		    	\item[• \textbf{\textcolor{darkgreen}{String} message}:] Contient le méssage à affiché 
		    	lorsque les conditions d'exécution sont \\validées.\\
		    	\item[• \textbf{\textcolor{red}{int} type = \textcolor{blue}{2}}:] Contient le type du 
		    	méssage qui sera affiché. Les valeurs possibles sont celles définient au sein de la méthode 
		    	\textit{\textcolor {blue}{\hyperlink{output}{output ()}}}.\\
		    \end{itemize}
		    \item[>> \textbf{\textcolor{darkgreen}{String} callback}:] Quel est le nom de la méthode à 
		    exécutée ? Cette clé est uniquement présente sur les clés: \textit{\textcolor {gray}{changed}} 
		    et \textit{\textcolor {gray}{value}}.\\
		\end{itemize}
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Array | Dictionary} data}:] Contient les configurations
			d'un ou de plusieurs propriétés d'un script. Si vous passez en paramètre une liste, celle-ci 
			devra que contenir des dictionaires. Le(s) \\dictionaire(s) à utilisé(s) acceptera/ont les clés 
			suivantes:
			\begin{itemize}
				\item[>> \textbf{\textcolor{darkgreen}{String} source}:] Contient le nom de la proprété à 
				créée ou son chemin d'accès. L'utilisation de cette clé est obligatoire.\\
				\item[>> \textbf{\textcolor{darkgreen}{Variant} value}:] Contient la valeur de la 
				propriété en question. Adaptez la valeur de votre propriété en fonction du type choisi. Il 
				est important de le faire si vous ne voulez pas avoir des résultats bizzards. Si vous passez
				une chaîne de caractères comme valeur, vous aurez la possibilité de récupérer la valeur
				d'une autre propriété ou du résultat que renvoie une méthode. \\Exemple:\\ 
				\textit{\textcolor{gray}{?property}} affectera à la propriété ciblée, la valeur de property.
				\\ \textit{\textcolor {gray}{?method()}} affectera à la propriété ciblée, ce que retourne 
				method.\\Vous avez également la possibilité donner un dictionaire supportant les clés:
				\textit{\textcolor {gray}{callback}} et \textit{\textcolor {gray}{params}}.\\
				\newpage \item[>> \textbf{\textcolor{darkgreen}{String | PoolStringArray} attach}:] Voulez-
				vous attacher des propriétés à cette propriété ? Pour éffectuer un attachement, vous devez 
				donner le(s) nom(s) des propriété(s) dont le comportement dépend de cette propriété.\\ 
				Exemple: Soit propriete1, propriete2, propriete3 et propriete4 quatres proprétés du script. 
				Les comportements des propriétés 2 et 3 dépendent de la valeur de propriete1 et celui de 
				propriete4, celle de propriete3. Ainsi, la valeur de la clé \textit{\textcolor {gray}
				{attach}} de propriete1 ciblera les noms des propriétés 2 et 3; celui de propriete3 ciblera 
				le nom de propriete4. Notez que l'utilisation de cette clé optimise l'exécution des
				configurations éffectuées au niveau toutes les propriétées du script. Il formellement 
				conseilé de l'utiliser pour éviter les exécutions hors du domaine prédéfinit.\\
				\item[>> \textbf{\textcolor{red}{int} type = \textcolor{blue}{0}}:] Quel type de donnée sera 
				contenu dans votre propriété ? Les valeurs possibles sont celles de Godot.\\
				\item[>> \textbf{\textcolor{red}{int} hint = \textcolor{blue}{0}}:] Quel est l'indice de la
				propriété ? Les valeurs possibles sont celles de Godot.\\
				\item[>> \textbf{\textcolor{red}{int} usage = \textcolor{blue}{71}}:] Quel est l'usage de la
				propriété dans l'éditeur ? Les valeurs possibles sont celles de Godot.\\
				\item[>> \textbf{\textcolor{red}{int} stream = \textcolor{blue}{2}}:] Par quel moyen on aura
				accès à la propriété ? Les valeurs possibles sont:
				\begin{itemize}
					\item [-> \textbf{\textcolor{gray}{MegaAssets.PropertyAccessMode.READ\_ONLY} ou
					\textcolor{blue}{0}}:] On accèdera à la propriété qu'en lecture seule.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.PropertyAccessMode.WRITE\_ONLY} ou
					\textcolor{blue}{1}}:] On accèdera à la propriété qu'en écriture seule.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.PropertyAccessMode.BOTH} ou
					\textcolor{blue}{2}}:] On accèdera à la propriété en lecture et écriture.\\
				\end{itemize}
				\item[• \textbf{\textcolor{red}{bool} saveable = \textcolor{red}{false}}:] Voulez-vous
				configurez la propriété afin qu'elle puisse répondre à la sauvegarde et au chargement des
				données du script ? N'utilisez cette propriété que si votre script hérite de la classe
				\textcolor {darkgreen}{Saveable} ou \textit{\textcolor {darkgreen}{Recordable}}.\\
				\item[• \textbf{\textcolor{darkgreen}{String} title}:] Voulez-vous changer la valeur du 
		    	texte inscrite sur la catégory \textit{\textcolor {gray}{Script Variables}} ?\\
		    	\item[• \textbf{\textcolor{darkgreen}{Vector2 | Vector3} range}:] Mets des valeurs limit
		    	sur une propriété définie comme étant un réel ou entier ? La première valeur est celle 
		    	minimale de la propriété. La seconde, celle maximale. Si vous utilisez une vecteur trois 
		    	dimension, la troisième valeur représente le pas à ajouté lorsqu'on modifie la valeur de la 
		    	propriété en question.\\
		    	\item[• \textbf{\textcolor{darkgreen}{String} hint\_string}:] Cette clé vous permet de 
		    	grouper plusieurs valeurs suivant des cas \\spécifiques. Son comportement est la même que 
		    	celle de Godot.\\								
				\item[>> \textbf{\textcolor{red}{bool} visible = \textcolor{red}{true}}:] La propriété sera
				t-elle visible parmit celles du script ?\\
				\item[>> \textbf{\textcolor{red}{bool} enabled = \textcolor{red}{true}}:] La propriété sera
				t-elle activée parmit celles du script ?\\
				\item[>> \textbf{\textcolor{red}{bool} duplicate = \textcolor{red}{false}}:] Va t-on
				dupliquer la dernière valeur de l'élément de la propriété à chaque ajout ? Cette
				fonctionalité ne fonctionne que les listes.\\
				\item[>> \textbf{\textcolor{red}{int} index = \textcolor{blue}{-1.0}}:] Contrôle la position 
				qu'occupe une propriété au sein de la présentation des différentes variables du script.\\
				\item[>> \textbf{\textcolor{red}{bool} private = \textcolor{red}{false}}:] La propriété sera
				t-elle privée ? A ce stade, vous n'avez plus la \\possibilité de récupérer, ni même de 
				modifier la valeur de cette dernière.\\
				\item[>> \textbf{\textcolor{darkgreen}{String | Dictionary} button}:] Cré une propriété 
				booléenne ayant le comportement d'un \\bouton.\\
				\item[>> \textbf{\textcolor{darkgreen}{String | Dictionary} changed}:] Ecoute la valeur de 
				la propriété et décide en cas de \\changement d'exécuter un callback donné par le
				dévoloppeur. Si vous donnez une chaîne de caractères, alors celle-ci doit référée le nom de 
				votre callback (méthode à exécutée lorsque la valeur de la propriété change). Si votre 
				méthode supporte deux ou plusieurs argument(s), la valeur du premier et celle du second
				seront respectivement remplacées par le nom de la propriété et sa valeur. N'oubliez pas ce
				détail.\\
				\item[>> \textbf{\textcolor{darkgreen}{Variant} dropdown}:] Souhaitez-vous transformer la
				propriété en une énumération ? Notez que si vous donnez un dictionaire, vous aurez la
				possibilité d'utiliser les clés suivantes:
				\begin{itemize}
				    \item[• \textbf{\textcolor{darkgreen}{Variant} value}:] Contient le(s) différente(s) 
				    valeur(s) de la liste déroulante.
				    \item[• \textbf{\textcolor{red}{int} behavior}:] Quel sera le comportement de la liste
				    déroulante. Les valeurs possibles sont:
				    \begin{itemize}
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.INPUT\_MAP} ou
						\textcolor{blue}{0}}:] Récupère la liste des entrées \\définient au sein de Godot.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.SIGNALS} ou
						\textcolor{blue}{1}}:] Récupère la liste des signaux \\définient au sein du script.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.TAGS} ou
						\textcolor{blue}{2}}:] Récupère la liste des groupes auquel appartient le noeud en
						question.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.METHODS} ou 
						\textcolor{blue}{3}}:] Récupère la liste de toutes les \\méthodes appartenant au
						script.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.TYPES} ou
						\textcolor{blue}{4}}:] Récupère la liste des types de base de Godot.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.OPERATORS} ou
						\textcolor{blue}{5}}:] Récupère la liste des opérateurs de Godot.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.MOUSE\_CONTROLS} ou 
						\textcolor{blue}{6}}:] Récupère la liste de \\toutes les touches de la souris. Notez 
						que vous pouvez également récupéré les codes des touches en mettant la clé 
						\textit{\textcolor{gray}{keycodes}} sur true. C'est la même chose au niveau des 
						touches de la manette et celles du clavier.
						\newpage \item[-> \textbf{\textcolor{gray}
						{MegaAssets.NaughtyAttributes.GAMEPAD\_CONTROLS}
						ou \textcolor{blue}{7}}:] Récupère la liste de toutes les touches de la manette.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.DESKTOP\_RESOLUTIONS}
						ou \textcolor{blue}{8}}:] Récupère la liste des résolutions d'écran possibles des
						ordinateurs de bureau. Notez que vous pouvez \\également récupéré les résolutions en
						mettant la clé \textit{\textcolor{gray}{sizes}} sur true. C'est la même chose au
						niveau des résolutions de l'ipad, l'iphone et de l'android.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.IPAD\_RESOLUTIONS}
						ou \textcolor{blue}{9}}:] Récupère la liste des résolutions d'écran possibles des 
						portables ipad.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.IPHONE\_RESOLUTIONS} 
						ou \textcolor{blue}{10}}:] Récupère la liste des résolutions d'écran possibles des 
						portables iphone.
						\item[-> \textbf{\textcolor{gray}
						{MegaAssets.NaughtyAttributes.ANDROID\_RESOLUTIONS} ou \textcolor{blue}{11}}:]
						Récupère la liste des résolutions d'écran possibles des portables android.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.KEYBOARD\_CONTROLS}
						ou \textcolor{blue}{12}}:] Récupère la liste de toutes les touches du clavier.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.SYSTEM\_DIR} ou 
						\textcolor{blue}{13}}:] Récupère la liste des chemins disponibles sur le système 
						d'exploitation installé. Notez que vous pouvez également récupéré les chemins en 
						mettant la clé \textit{\textcolor{gray}{paths}} sur true.
						\item[-> \textbf{\textcolor{gray}{MegaAssets.NaughtyAttributes.GAME\_CONTROLLERS} 
						ou \textcolor{blue}{14}}:] Récupère la liste des commandes connectées au jeu. Notez 
						que cette option écouté les commandes \\connectées à l'ordinateur pour donner en
						temps réel les commandes disponibles. \\Notez que les comportements d'une liste
						déroulante sont prioritaire devant la valeur même de cette dernière.\\
					\end{itemize}
				\end{itemize}
				\item[>> \textbf{\textcolor{darkgreen}{String | Dictionary} showif}:] Détermine si 
				une propriété sera visible dans les variables du script ou pas en fonction de la condition 
				imposée par le développeur. IDEM pour la clé \textit{\textcolor{gray}{\\disableif}} qui 
				s'occupe de l'activation ainsi que de la désactivation d'une propriété.\\
				\item[>> \textbf{\textcolor{darkgreen}{Array | Dictionary} clone}:] Détecte la présence de 
				doublons en fonction de l'identifiant qui lui a été donné. Si vous donnez un tableau, alors 
				celui-ci devra que contenir des dictionaires supportant les mêmes clés que si vous passez un 
				dictionaire ordinaire. Si vous donnez un dictionaire, alors il supportera les clés 
				suivantes:
				\begin{itemize}
				    \item[• \textbf{\textcolor{darkgreen}{Variant} id}:] Contient un identifiant dont-on
				    souhaite vérifié des duplications au sein de ces valeurs.
				    \item[• \textbf{\textcolor{red}{int} limit = \textcolor{blue}{1}}:] Quel est le critère 
				    de répétition des valeurs de l'identifiant choisi ?\\
				\end{itemize}
				\item[>> \textbf{\textcolor{darkgreen}{Dictionary | Vector2 | Vector3} | \textcolor{red}
				{float | int} min}:] Force la valeur de la propriété à restée à celle minimale imposée. 
				Notez que cette clé n'est utilisée que si le type de la propriété est un entier, réel, 
				vecteur 2d ou vecteur 3d. Si vous donnez un dictionaire, alors il supportera les clés 
				suivantes:
				\begin{itemize}
					\item[• \textbf{\textcolor{red}{int | float} | \textcolor{darkgreen}{Vector2 | Vector3} 
					value}:] Contient la valeur minimale de la propriété.
					\item[• \textbf{\textcolor{red}{int} index = \textcolor{blue}{-1}}:] Quelle valeur 
					voulez-vous ciblée ? N'utilisez cette clé que si la propriété que vous manipulez est un 
					vecteur 2d ou vecteur 3d.
				\end{itemize}
				Même concepte pour clé \textit{\textcolor{gray}{max}}.\\
				\item[>> \textbf{\textcolor{darkgreen}{Dictionary | Array | String} require}:] Ajoute une
				certaine contrainte à la valeur d'une \\propriété. Si vous donnez une chaîne de caractères,
				elle sera considérée comme un méssage d'erreur à affiché tanqu'on ne changera pas la valeur
				initiale de la propriété. Si vous donnez un tableau, alors celui-ci devra que contenir des
				dictionaires supportant les mêmes clés que si vous passez un dictionaire ordinaire.\\
				\item[>> \textbf{\textcolor{darkgreen}{Dictionary | Array} notification}:] Ecoute les 
				notifications de l'éditeur pour ensuite exécuter les configurations éffectuées à son égard. 
				Si vous donnez un tableau, alors celui-ci devra que contenir des dictionaires supportant les 
				mêmes clés que si vous passez un dictionaire ordinaire. Si vous donnez un dictionaire, alors 
				il supportera les clés suivantes:
				\begin{itemize}
					\item[• \textbf{\textcolor{red}{int} what}:] Quelle notification voulez-vous écouter ?\\
				\end{itemize}
				\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'ajout de la 
				propriété en question ?\\
			\end{itemize}
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Slot1 method definition.
		func slot1 (value): print ("Boolean: ", value);
		# Slot2 method definition.
		func slot2 (value): print (value);
		# Slot3 method definition.
		func slot3 (param): return param;
		# Consts definition.
		var CONST1 = false; var CONST2 = "OS dropdown";
		# Called on class initialisation.
		func _init ():
			# Change script title.
			self.bind_prop ({title = "ModuleType", index = 0});
			# Adding a boolean property.
			self.bind_prop ({
				source = "Features/Range", type = TYPE_REAL, value = 1, range = Vector2 (0, 5),
				attach = "range"
			});
			# Adding a boolean property.
			self.bind_prop ({
				source = "Features/Boolean", type = TYPE_BOOL, value = "?CONST1",
				changed = {callback = "slot1", params = null}, attach = "integer"
			});
			# Adding an integer property.
			self.bind_prop ({
				source = "Features/Integer", type = TYPE_INT, value = 0, attach = "integer",
				min = {value = 0, actions = {slot = "slot2 ()", params = "Min value of integer"}},
				max = {value = 10, actions = {slot = "slot2 ()", params = "Max value of integer"}},
				showif = {statement = "boolean"},
				notification = [{
					what = NOTIFICATION_ENTER_TREE,
					actions = {slot = "slot2 ()", params = "Start Game",
					message = "Enter tree", type = Message.NORMAL}
				}, {
					what = NOTIFICATION_EXIT_TREE,
					actions = {slot = "slot2 ()", params = "Stop Game",
					message = "Exit tree", type = Message.NORMAL}
				}]
			});
			# Adding an OS dropdown property.
			self.bind_prop ({
				source = "Features/OS Dropdown",
				dropdown = ["Desktop", "Ipad", "Iphone", "Android"],
				value = 0, disableif = "not nodepath is Camera",
				attach = ["selecTED Os", "Resolutions dropdown"]
			});
			# Adding a screen resolutions dropdown.
			self.bind_prop ({
				source = "Resolutions Dropdown", value = 0,
				dropdown = {behavior = NaughtyAttributes.DESKTOP_RESOLUTIONS},
				disableif = "not nodepath is Camera", attach = "resolutions dropdown",
				require = [{
					statement = "os dropdown == 0",
					actions = {
						slot = "resolutions dropdown",
						value = {
							dropdown = {behavior = NaughtyAttributes.DESKTOP_RESOLUTIONS}
						}
					}
				}, {
					statement = "OS dropdown == 1",
					actions = {
						slot = "resolutions dropdown",
						value = {
							dropdown = {behavior = NaughtyAttributes.IPAD_RESOLUTIONS}
						}
					}
				}, {
					statement = "oS DROPdown == 2",
					actions = {
						slot = "resolutions dropdown",
						value = {
							dropdown = {behavior = NaughtyAttributes.IPHONE_RESOLUTIONS}
						}
					}
				}, {
					statement = "OS DROPDOWN == 3",
					actions = {
						slot = "resolutions dropdown",
						value = {
							dropdown = {behavior = NaughtyAttributes.ANDROID_RESOLUTIONS}
						}
					}
				}]
			});
			# Adding a node path.
			self.bind_prop ({
				source = "NodePath", index = 0, type = TYPE_NODE_PATH, value = NodePath (''),
				attach = ["NODEPATH", "OS DropDOWN", "RESOlutiONS drOPDown"],
				require = [{
					statement = "!nodepath is Camera",
					actions = {
						message = "You should donate an instance of camera.",
						type = Message.ERROR
					}
				}, {
					statement = "Nodepath is Camera",
					actions = {
						message = "NodePath property value is [OK]",
						type = Message.NORMAL
					}
				}]
			});
			# Adding an array.
			self.bind_prop ({
				source = "Array", type = TYPE_ARRAY, value = Array ([]), duplicate = true,
				attach = "array"
			});
			# Adding a reset value button.
			self.bind_prop ({
				source = "ResetValues",
				button = {
					actions = {slot = "reset_props_value ()", params = ["ResetVALUES", null]}
				}
			});
			# Adding a selected os name listener.
			self.bind_prop ({
				source = "Selected OS", type = TYPE_STRING, value = String ("No OS seclected"),
				attach = "selected os",
				require = {
					statement = "os dropdown >= 0",
					actions = {
						slot = "sEleCtED Os",
						value = {
							value = {
								callback = "get_prop",
								params = [{callback = "slot3", params = "?CONST2"}, true]
							}
						}
					}
				}
			});
		# Calls on editor notification.
		func _notification (what): self.listen_notifications (what);
		# Gets all script variables list.
		func _get_property_list (): return self.get_properties ();
		# Calls to return property value changed.
		func _get (property): return self.get_prop (property);
		# Calls to set property editor value.
		func _set (property, value): self.set_prop (property, value, true);
	\end{lstlisting}
	% Void listen_notifications () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{\hypertarget{listennotifications}
		{listen\_notifications}} (what, delay = 0.0)]: Ecoute les notifications de l'éditeur pour pouvoir 
		ensuite déclenché les configurations éffectuées à propos de la clé \textit{\textcolor{gray}
		{notification}} sur les variables d'un script.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{int} what}:] Contient la notification de l'éditeur à écoutée.
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'écoute de chaque 
			notification de l'éditeur.\\
		\end{itemize}
	\end{description}
	% Static Variant get_id_value_of () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{get\_id\_value\_of} 
		(id, input, index = -1, count = -1, rev = false, rec = true)]: \\Renvoie la ou les valeur(s) 
		associée(s) à l'identifiant contenu dans un dictionaire ou tableau.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Variant} id}:] Contient l'identifiant contenue dans le 
			dictionaire ou tableau à utilisé.
			\item[>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient un tableau ou dictionaire.
			\item[>> \textbf{\textcolor{red}{int} index}:] Contient l'index de position de la valeur de 
			l'identifiant référé.
			\item[>> \textbf{\textcolor{red}{int} count}:] Combien de résultat aurons nous en sorti ? Une
			valeur négative entraînera le renvoie de tous les résultats trouvés au cours du traitement.
			\item[>> \textbf{\textcolor{red}{bool} rev}:] Souhaitez-vous inverser l'ordre des traitements à
			éffectués ?
			\item [>> \textbf{\textcolor{red}{bool} rec}:] Renvoyer le(s) valeur(s) de l'identifiant en
			utilisant un programme récursive ?\\
		\end{itemize}
	\end{description}
	% Void reset_props_value () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{reset\_props\_value} (trigger, prop = null, delay = 
		0.0)]: Rénitialise la valeur d'un ou de plusieurs propriétés.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{String} trigger}:] Contient le nom de la propriété ayant
			déclenché cette méthode. C'est un peu bizzard pour vous, mais lorsqu'il s'agira de rénitialiser 
			toutes les propriétés, celui-ci deviendra incontournable pour éviter que l'éditeur ne se ferme 
			de lui même.
			\item[>> \textbf{\textcolor{darkgreen}{Variant} prop}:] Contient le(s) nom(s) de la ou des 
			propriété(s) à rénitialisée(s). Si aucune \\propriété n'est référée, alors toutes les propriétés
			disponibles seront rénitialisée(s).
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant la 
			rénitialisation de la ou des propriétés ciblée(s) ?\\
		\end{itemize}
	\end{description}
	% Array get_properties () method description.
	\begin{description}
		\item [+ \textcolor{darkgreen}{Array} \textcolor{blue}{get\_properties} (invert = false)]: Renvoie 
		la liste de toutes les propriétés définient au sein du dictionaire \textit{\textcolor {gray}
		{\_\_props\_\_}}. Ce dictionaire est une propriété spéciale définie dans la classe 
		\textbf{\textcolor {darkgreen}{\\MegaAssets}}. Ainsi, tous script héritant de cette classe possède 
		cette dernière avec laquelle \\interagiront les méthodes \textit{\textcolor {blue}
		{\hyperlink{bindprop}{bind\_prop ()}, get\_properties (), reset\_props\_value (), destroy\_props (), 
		\\override\_prop ()}} et \textit{\textcolor {blue}{\hyperlink{listennotifications}
		{listen\_notification ()}}}.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{bool} invert}:] Voulez-vous inverser l'ordre d'alignement des
			propriétés ?\\
		\end{itemize}
	\end{description}
	% Void destroy_props () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{destroy\_props} (source, delay = 0.0)]: Détruit un 
		ou plusieurs propriété(s) associée(s) à un script.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{String | PoolStringArray} source}:] Contient les noms de
			toutes les popriétés à détruire.
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant le(s) destructions
			?\\
		\end{itemize}
	\end{description}
	% Void override_prop () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{override\_prop} (data, prop\_name, delay = 0.0)]: 
		Redéfinit une propriété donnée.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Dictionary} data}:] Contient les nouvelles configurations
			relatives au propriété à redéfinir.
			\item[>> \textbf{\textcolor{darkgreen}{String} prop\_name}:] Contient le nom de la propriété à
			redéfinir.
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant la redéfinition ?
			\\
		\end{itemize}
	\end{description}
	% Static String any_to_str () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{any\_to\_str} 
		(input)]: Converti une entrée en chaîne de caractères. Attention, le \\comportement de cette méthode 
		est différente lorsque l'entrée fournit est un tableau.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient une valeur à convertir.\\
		\end{itemize}
	\end{description}
	% Static String | Array array_invert () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String | Array} \textcolor{blue}
		{array\_invert} (array)]: Inverse l'ordre d'alignement des éléments contenu dans un tableau. Cette
		méthode supporte également une chaîne de caractères.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Variant} array}:] Contient un tableau à inversé.\\
		\end{itemize}
	\end{description}
	% Static Variant get_clones_of () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{get\_clones\_of} 
		(id, input, limit = 1)]: Quelles sont les valeurs dont le nombre \\d'occurence est immédiatement 
		supérieur à la limite imposée ?
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Variant} id}:] Contient l'identifiant contenue dans le 
			dictionaire ou tableau à utilisé.
			\item[>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient un tableau ou dictionaire.
			\item[>> \textbf{\textcolor{red}{int} limit}:] Quel est critère de répétition des valeurs ?\\
		\end{itemize}
	\end{description}
	% Static Variant set_id_value_of () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{set\_id\_value\_of} 
		(id, value, input, index = -1, typed = false, rec = true)]: \\Modifie la valeur d'un identifiant 
		dans un dictionaire ou tableau. L'influence de cette méthode \\est récursive à l'entrée donnée.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Variant} id}:] Contient l'identifiant contenue dans le 
			dictionaire ou tableau à utilisé.
			\item[>> \textbf{\textcolor{darkgreen}{Variant} value}:] Contient la nouvelle valeur à affectée
			à l'identifiant en question.
			\item[>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient un tableau ou dictionaire.
			\item[>> \textbf{\textcolor{red}{int} index}:] Parmit les doublons de l'identifiant sélectionés
			lequel ciblé ?
			\item[>> \textbf{\textcolor{red}{bool} typed}:] Devons nous changer la valeur de l'identifiant 
			en se basant sur le type de sa valeur ?
			\item [>> \textbf{\textcolor{red}{bool} rec}:] Modifier le(s) valeur(s) de l'identifiant en 
			utilisant un traitement récursive ?\\
		\end{itemize}
	\end{description}
	% Static PoolStringArray | PoolVector2Array get_desktop_resolutions () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray | PoolVector2Array} 
		\textcolor{blue}{get\_desktop\_resolutions} (to\_string = true)]: \\Renvoie les résolutions 
		possibles d'écran que peuvent avoir les ordinateurs.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{bool} to\_string}:] Le résultat sera t-elle sous forme de 
			chaine de caractères ?\\
		\end{itemize}
	\end{description}
	% Static PoolStringArray | PoolVector2Array get_ipad_resolutions () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray | PoolVector2Array} 
		\textcolor{blue}{get\_ipad\_resolutions} (to\_string = true)]: \\Renvoie les résolutions possibles
		d'écran que peuvent avoir les portables Ipad.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{bool} to\_string}:] Le résultat sera t-elle sous forme de 
			chaine de caractères ?\\
		\end{itemize}
	\end{description}
	% Static PoolStringArray | PoolVector2Array get_iphone_resolutions () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray | PoolVector2Array} 
		\textcolor{blue}{get\_iphone\_resolutions} (to\_string = true)]: \\Renvoie les résolutions possibles
		d'écran que peuvent avoir les portables Iphone.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{bool} to\_string}:] Le résultat sera t-elle sous forme de 
			chaine de caractères ?\\
		\end{itemize}
	\end{description}
	% Static PoolStringArray | PoolVector2Array get_android_resolutions () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray | PoolVector2Array} 
		\textcolor{blue}{get\_android\_resolutions} (to\_string = true)]: \\Renvoie les résolutions 
		possibles d'écran que peuvent avoir les portables Android.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{bool} to\_string}:] Le résultat sera t-elle sous forme de 
			chaine de caractères ?\\
		\end{itemize}
	\end{description}
	% Static Variant get_initialised_type () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{get\_initialised\_type} (input)]: Renvoie la version initialisée de la valeur donnée en paramètre 
		en fonction de son type de contenu. Les types
		\href{https://docs.godotengine.org/fr/stable/classes/class_rid.html}
		{\textit{\textcolor{darkgreen}{Rid}}} et
		\href{https://docs.godotengine.org/fr/stable/classes/class_object.html}
		{\textit{\textcolor{darkgreen}{Object}}} ne sont prises en charge dans cette méthode.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient une valeur quelconque. 
			Attention, le type de donnée référée doit être parmit les type de base.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			print (MegaAssets.get_initialised_type (125)); # Return 0
			print (MegaAssets.get_initialised_type ("Mother")); # Return ""
			print (MegaAssets.get_initialised_type (false)); # Return false
			print (MegaAssets.get_initialised_type (15.36)); # Return 0.0
			print (MegaAssets.get_initialised_type (["false", 12, Vector2.UP])); # Return []
			print (MegaAssets.get_initialised_type ({name = "Mother"})); # Return {}
			print (MegaAssets.get_initialised_type (Vector2 (0.36, -96.14))); # Return (0.0, 0.0)
	\end{lstlisting}
	% Static PoolStringArray get_godot_base_types () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray} \textcolor{blue}
		{get\_godot\_base\_types} ()]: Renvoie la liste de toutes les types de bases prises en charge dans
		Godot.\\
	\end{description}
	% Static PoolStringArray get_godot_operators () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray} \textcolor{blue}
		{get\_godot\_operators} ()]: Renvoie la liste de toutes les opérateurs de \\Godot.\\
	\end{description}
	% Static PoolStringArray | PoolIntArray get_mouse_controls () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray | PoolIntArray} 
		\textcolor{blue}{get\_mouse\_controls} (keycode = false)]: Renvoie la liste de toutes les touches
		de la souris.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{bool} keycode}:] Désirez-vous recevoir uniquement les codes
			ascii des touches de la souris ?\\
		\end{itemize}
	\end{description}
	% Static PoolStringArray | PoolIntArray get_joystick_controls () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray | PoolIntArray} 
		\textcolor{blue}{get\_joystick\_controls} (keycode = false)]: Renvoie la \\liste de toutes les 
		touches de la manette.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{bool} keycode}:] Désirez-vous recevoir uniquement les codes
			ascii des touches de la manette ?\\
		\end{itemize}
	\end{description}
	% Static PoolStringArray | PoolIntArray get_keyboard_controls () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolStringArray | PoolIntArray} 
		\textcolor{blue}{get\_keyboard\_controls} (keycode = false)]: Renvoie la \\liste de toutes les 
		touches du clavier.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{bool} keycode}:] Désirez-vous recevoir uniquement les codes
			ascii des touches du clavier ?\\
		\end{itemize}
	\end{description}
	% Static bool is_undefined () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_undefined} (target, object)]: La ou les 
		propriétés ou la ou les \\méthodes données sont-elles toutes définient dans l'instance de l'objet
		référée ?
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{String | PoolStringArray} target}:] Quelles sont le(s) 
			des méthodes ou des propriétés à \\cherchées ?
			\item[>> \textbf{\textcolor{darkgreen}{Object} object}:] Contient l'instance d'un élément de 
			type \href{https://docs.godotengine.org/fr/stable/classes/class_object.html}
			{\textit{\textcolor{darkgreen}{Object}}}.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Create some variables.
		var player_life = 25;
		var player_energy = 69;
		# Create a method.
		func parser (): print ("Hello world !");
		# Called after game is ready.
		func _ready ():
			print (MegaAssets.is_undefined ("player_life", self)); # Return false
			print (MegaAssets.is_undefined ("life", self)); # Return true
			print (MegaAssets.is_undefined ("parser", self)); # Return false
			print (MegaAssets.is_undefined (["parser", "player_energy"], self)); # Return false
			print (MegaAssets.is_undefined (["mana", "piece"], self)); # Return true
	\end{lstlisting}
	% Static String get_object_prefix () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{get\_object\_prefix} 
		(object)]: Renvoie les informations de bases sur l'instance d'un objet.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Object} object}:] Contient l'instance d'un élément de
			type \href{https://docs.godotengine.org/fr/stable/classes/class_object.html}
			{\textit{\textcolor{darkgreen}{Object}}}.\\
		\end{itemize}
	\end{description}
	% Static String get_joy_category () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{get\_joy\_category} 
		(jname, object, path = "...")]: Renvoie le nom de la catégory \\associé au nom de la manette référé.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{String} jname}:] Contient le nom de la manette en 
			question.
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer 
			les différentes opérations ?
			\item[>> \textbf{\textcolor{darkgreen}{String} path}:] Contient le chemin pointant vers le 
			fichier de configuration (.cfg) des manettes non reconnu par cette methode. Pour editer ce
			ficher, vous devez suivre la nomenclature \\suivante:\\
			\{gamepads\}\\
			NomDeLaManette1 = CategoryDeLaManette1 (Playstation, Xbox, Nitendo, etc...)\\
			NomDeLaManette2 = CategoryDeLaManette2 (Playstation, Xbox, Nitendo, etc...)\\
			...\\
			NomDeLaManetteN = CategoryDeLaManetteN (Playstation, Xbox, Nitendo, etc...)\\
			Les alcolades autour de \textit{\textcolor{gray}{gamepads}} seront remplacés par des crochets.
			Comme vous pouvez le constaté, un chemin par défaut est donné. Notez que des catégories de
			manettes ont été déjà renseignés dans le fichier de configuration que cible cette méthode.
			La valeur par défaut de ce paramètre est: \textit{\textcolor{gray}{res://addons/mega\_assets/
			nodes/base/mega\_assets/gamepads.cfg}}.\\
		\end{itemize}
	\end{description}
	% Static Variant get_detected_controllers_names () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{get\_detected\_controllers\_names} (limit = -1)]: Renvoie la liste des commandes détectées dans 
		l'intervalle de détection imposé par le développeur.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{int} limit}:] Quelle est la limite de détection des commandes ?
			Une value nulle inhibe tout \\détection. Une valeur positive génère un intervalle de détection 
			et une valeur négative rend ilimitées les détections.\\
		\end{itemize}
	\end{description}
	% Static Dictionary get_game_statistiques () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Dictionary} \textcolor{blue}
		{get\_game\_statistiques} (object)]: Renvoie les caractéristiques générales liées au jeu.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer 
			les différentes opérations ?\\
		\end{itemize}
	\end{description}
	% Static Dictionary get_computer_statistiques () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Dictionary} \textcolor{blue}
		{get\_computer\_statistiques} ()]: Renvoie les caractéristiques générales liées à \\l'ordinateur
		ainsi qu'a son système d'exploitation.\\
	\end{description}
	% Static void debug_data () method description.
	\newpage \begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{debug\_data} (visible, object, data = \{\}, 
		options = \{\}, filter = null, delay = 0.0)]: \\Affiche en temps réel les différentes données 
		contenues dans le paramètre \textit{\textcolor{gray}{data}}. N'appelez cette méthode que si le jeu 
		en cours d'exécution.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{bool} visible}:] Devons-nous afficher les données issues du
			débogage ?
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer 
			les différentes opérations ?
			\item[>> \textbf{\textcolor{darkgreen}{Dictionary} data}:] Contient les différentes données à
			affichées pour le débogage.
			\item[>> \textbf{\textcolor{darkgreen}{Dictionary} options}:] Contient les différentes 
			configurations pour la gestion de l'affichage des données. Ce dictionaire supporte les clés 
			suivantes:
			\begin{itemize}
				\item[>> \textbf{\textcolor{red}{bool} vspace = \textcolor{red}{false}}:] Voulez-vous 
				ajouter une space verticale sur l'ensemble des données matérialisées ?
				\item[>> \textbf{\textcolor{red}{int} mrgtop = \textcolor{blue}{0}}:] Ajoute une marge en 
				haut de l'ensemble des données représentées.
				\item[>> \textbf{\textcolor{red}{int} mrgleft = \textcolor{blue}{0}}:] Ajoute une marge à 
				gauche de l'ensemble des données représentées.
				\item[>> \textbf{\textcolor{red}{int} mrgright = \textcolor{blue}{0}}:] Ajoute une marge à 
				droite de l'ensemble des données représentées.
				\item[>> \textbf{\textcolor{red}{int} mrgbottom = \textcolor{blue}{0}}:] Ajoute une marge en 
				bas de l'ensemble des données représentées.
				\item[>> \textbf{\textcolor{red}{int} charcount = \textcolor{blue}{-1}}:] Combien de 
				caractères voulez-vous afficher sur l'ensemble des données affichées ?
				\item[>> \textbf{\textcolor{red}{bool} uppercase = \textcolor{red}{false}}:] Souhaitez-vous
				mettre en majuscule l'ensemble des données \\repésentées ?
				\item[>> \textbf{\textcolor{darkgreen}{Color} color = \textcolor{darkgreen}{Color}.white}:]
				Contrôle le couleur de toutes les données matérialisées par le débogage.
			\end{itemize}
			Notez que vous avez la possibilité de personnalisé les propriétés de chaque donnée repésentée.
			Il suffit simplement de préciser le nom de la clé correspondant à la donnée à personnalisée et
			de lui affectée un dictionaire supportant les clés: \textit{\textcolor{gray}{mrgtop, mrgbottom,
			mrgleft, mrgright, color, charcount et uppercase}}.
			\item[>> \textbf{\textcolor{darkgreen}{Array | String | PoolStringArray} filter}:] Contient
			le(s) clé(s) des éléments qui seront \\repésentés au cours du débogage.
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant la matérialisation 
			des données ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called every frame. "delta" is the elapsed time since the previous frame.
		func _process (delta):
			# Show game statistiques.
			MegaAssets.debug_data (true, self, {
				fps = Engine.get_frames_per_second (),
				"Window Width": OS.window_size.x
			}, {
				mrgtop = 15, mrgleft = 15, color = Color.chartreuse,
				fps = {color = Color.red},
				"Window Width": {mrgtop = 2, mrgleft = 5}
			});
	\end{lstlisting}
	% Static void apply_game_settings () method description.
	\newpage \begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{apply\_game\_settings} (settings, object,
		nodes, delay = 0.0)]: Modifie les \\configurations globales du jeu. N'appelez cette méthode que si 
		le jeu en cours d'exécution.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Dictionary} settings}:] Contient les différentes
			paramètres pour la gestion des configurations \\globales du jeu. Ce dictionaire supporte les
			clés suivantes:
			\begin{itemize}
				\item[>> \textbf{\textcolor{red}{float} volume}:] Contrôle le volume des éffets sonores du 
				jeu. Ces valeurs sont dans \\l'intervalle de [\textcolor{blue}{0.0}; \textcolor{blue}
				{100.0}]. Notez qu'il faut que les éffets sonores doivent être permit avant de pouvoir 
				varier leur volume.\\
				\item[>> \textbf{\textcolor{red}{int} quality = \textcolor{blue}{0}}:] Contrôle le degré de 
				qualité du jeu. Les valeurs possibles sont:
				\begin{itemize}
					\item [-> \textbf{\textcolor{gray}{MegaAssets.GameQuality.LOW} ou \textcolor{blue}{0}}:] 
					Mauvaise qualité.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.GameQuality.MEDIUM} ou \textcolor{blue}
					{1}}:] Qualité moyen.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.GameQuality.HIGH} ou \textcolor{blue}
					{2}}:] Bonne qualité.\\
				\end{itemize}
				\item[>> \textbf{\textcolor{red}{int} orientation = \textcolor{blue}{0}}:] Voire la
				documentation de Godot sur la propriété \href{https://docs.godotengine.org/en/stable/classes/class_os.html#class-os-property-screen-orientation}{\textit{\textcolor{blue}{ScreenOrientation}}}.\\
				\item[>> \textbf{\textcolor{red}{bool} borderless = \textcolor{red}{false}}:] Voulez-vous 
				supprimer le cadre définissant la fenêtre du jeu ? En d'autres termes, souhaitez-vous 
				supprimer la barre de titre ?\\
				\item[>> \textbf{\textcolor{red}{bool} foreground = \textcolor{red}{false}}:] Voulez-vous 
				mettre en premier plan la fenêtre du jeu ?\\
				\item[>> \textbf{\textcolor{red}{bool} resizable = \textcolor{red}{true}}:] Voulez-vous 
				permettre le redimentionnement de la fenêtre du jeu ?\\
				\item[>> \textbf{\textcolor{darkgreen}{Vector2} resolution = \textcolor{darkgreen}{Vector2}
				(\textcolor{blue}{1024}, \textcolor{blue}{600})}:] Contrôle la taille de la fenêtre du jeu.
				\\
				\item[>> \textbf{\textcolor{darkgreen}{Vector2} minsize = \textcolor{darkgreen}{Vector2}
				(\textcolor{blue}{0}, \textcolor{blue}{0})}:] Quelle est la résolution minimale de la 
				fenêtre du jeu ? Si ne serais que l'une des valeurs de ce vecteur est négative ou nulle, on 
				considera que la valeur minimale de cette dernière est nulle. Ne donnez pas une résolution 
				suppérieur à celle de la fenêtre du jeu.\\
				\item[>> \textbf{\textcolor{darkgreen}{Vector2} maxsize = \textcolor{darkgreen}{Vector2}
				(\textcolor{blue}{0}, \textcolor{blue}{0})}:] Quelle est la résolution maximale de la 
				fenêtre du jeu ? Si ne serais que l'une des valeurs de ce vecteur est inférieur à la 
				résolution actuelle de la fenêtre du jeu, on considera que la taille maximale est égale à 
				celle actuelle au sein de la fenêtre du jeu. Ne donnez pas une résolution suppérieur à ce
				que peut supporté l'écran de votre machine.\\
				\item[>> \textbf{\textcolor{darkgreen}{Vector2} position = \textcolor{darkgreen}{Vector2}
				(\textcolor{blue}{-1}, \textcolor{blue}{-1})}:] Quelle est la position de la fenêtre du 
				jeu ? Si ne serais que l'une des valeurs de ce vecteur est négative, cette dernière sera 
				automatiquement \\centrée sur l'écran à la valeur ne respectant pas les conditions d'une 
				résolution à la \\première exécution du jeu.\\
				\item[>> \textbf{\textcolor{red}{bool} maximize = \textcolor{red}{false}}:] Voulez-vous 
				maximiser la taille de la fenêtre du jeu ? Si cette \\fonctionnalité est activée, la fenêtre 
				du jeu sera redimentionnée à la résolution maximale de l'écran.\\
				\item[>> \textbf{\textcolor{red}{bool} fullscreen = \textcolor{red}{false}}:] Contrôle le 
				mode plein écran du jeu.\\
				\item[>> \textbf{\textcolor{red}{int} brightness = \textcolor{blue}{13}}:] Contrôle la 
				luminosité de l'écran dans le jeu. Ces valeurs sont dans \\l'intervalle de [\textcolor{blue}
				{0}; \textcolor{blue}{100}].\\
				\item[>> \textbf{\textcolor{red}{int} contrast = \textcolor{blue}{13}}:] Contrôle l'effet 
				subjectif d'une apposition quantitative de couleurs. Ces valeurs sont dans l'intervalle de 
				[\textcolor{blue}{0}; \textcolor{blue}{100}].\\
				\item[>> \textbf{\textcolor{red}{int} saturation = \textcolor{blue}{13}}:] Contrôle la 
				pureté de la couleur de l'écran dans le jeu. Ces valeurs sont dans l'intervalle de 
				[\textcolor{blue}{0}; \textcolor{blue}{100}].\\
				\item[>> \textbf{\textcolor{red}{bool} vsync = \textcolor{red}{true}}:] Voulez-vous activer 
				la synchrônisation verticale au cours de l'exécution du jeu ?\\
				\item[>> \textbf{\textcolor{red}{bool} vsyncompositor = \textcolor{red}{false}}:] Voulez-
				vous activer la synchrônisation verticale par le biais d'un compositeur au cours de
				l'exécution du jeu ? Dans ce cas, le compositeur de fenêtre du système d'exploitation sera 
				utilisé lorsque le jeu est uniquement en mode fenêtré. Notez que cette option n'est activée 
				que sur un système d'exploitation de type Windows et est également expérimentale et destinée 
				à atténuer le bégaiement ressenti par certains \\utilisateurs. Cependant, certains 
				utilisateurs ont subi une réduction de moitié de la \\fréquence d'images (par exemple, de 60
				FPS à 30 FPS) lors de leur utilisation.\\
				\item[>> \textbf{\textcolor{red}{bool} keepscreen = \textcolor{red}{true}}:] Désirez-vous 
				garder l'écran actif lorsque le jeu est en cours \\d'exécution.\\
				\item[>> \textbf{\textcolor{red}{bool} optimization = \textcolor{red}{false}}:] Voulez-vous 
				optimiser l'utilisation du processeur ? A ce niveau, le rafraîchissement de l'écran n'est 
				fait que si cela est nécessaire afin de réduire la \\consommation de la batterie. Utile pour 
				les appareils portables.
			\end{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer 
			les différentes opérations ?
			\item[>> \textbf{\textcolor{darkgreen}{Array | String | NodePath | PoolStringArray} nodes}:] 
			Contient les différent(s) noeud(s) à \\ciblé(s) pour l'application de la valeur de certaines 
			clés du dictionaire fournit. Cet paramètre supporte les noeuds de type
			\href{https://docs.godotengine.org/fr/stable/classes/class_camera.html}
			{\textit{\textcolor{darkgreen}{Camera}}} et
			\href{https://docs.godotengine.org/fr/stable/classes/class_worldenvironment.html}
			{\textit{\textcolor{darkgreen}{WorldEnvironment}}} pour mettre à jour la valeur des propriétés
			\href{https://docs.godotengine.org/fr/stable/classes/class_environment.html#class-environment-property-adjustment-saturation}{\textit{\textcolor{blue}{Saturation}}},
			\href{https://docs.godotengine.org/fr/stable/classes/class_environment.html#class-environment-property-adjustment-contrast}{\textit{\textcolor{blue}{Contrast}}},
			\href{https://docs.godotengine.org/fr/stable/classes/class_environment.html#class-environment-property-adjustment-brightness}{\textit{\textcolor{blue}{Brightness}}} et
			\href{https://docs.godotengine.org/fr/stable/classes/class_environment.html#class-environment-property-tonemap-mode}{\textit{\textcolor{blue}{Mode}}};
			\href{https://docs.godotengine.org/fr/stable/classes/class_audiostreamplayer.html}
			{\textit{\textcolor{darkgreen}{AudioStreamPlayer}}},
			\href{https://docs.godotengine.org/fr/stable/classes/class_audiostreamplayer2d.html}
			{\textit{\textcolor{darkgreen}{AudioStreamPlayer2D}}} et
			\href{https://docs.godotengine.org/fr/stable/classes/class_audiostreamplayer3d.html}
			{\textit{\textcolor{darkgreen}{AudioStreamPlayer3D}}} pour mettre à jour la valeur des
			propriétés \href{https://docs.godotengine.org/fr/stable/classes/class_audiostreamplayer.html#class-audiostreamplayer-property-volume-db}{\textit{\textcolor{blue}
			{VolumeDB}}} et \href{https://docs.godotengine.org/fr/stable/classes/class_audiostreamplayer3d.html#class-audiostreamplayer3d-property-max-db}{\textit{\textcolor{blue}
			{MaxDB}}}.
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'application des 
			configurations ?\\
		\end{itemize}
	\end{description}
	% Static String get_os_dir () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{get\_os\_dir} 
		(path)]: Renvoie le chemin réel pointant vers un dossier se trouvant sur le système d'exploitation.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{int} path}:] Quel dossier souhaitez-vous ciblé ? Les valeurs
			possibles sont:
			\begin{itemize}
				\item[-> \textbf{\textcolor{gray}{MegaAssets.Path.GAME\_LOCATION} ou \textcolor{blue}{0}}:] 
				Cible le dossier racine du jeu.
				\item[-> \textbf{\textcolor{gray}{MegaAssets.Path.OS\_ROOT} ou \textcolor{blue}{1}}:] Cible 
				le dossier racine du système d'exploitation \\installé.
				\item[-> \textbf{\textcolor{gray}{MegaAssets.Path.USER\_DATA} ou \textcolor{blue}{2}}:] 
				Cible le dossier racine des données de l'utilisateur.
				\item[-> \textbf{\textcolor{gray}{MegaAssets.Path.USER\_ROOT} ou \textcolor{blue}{3}}:] 
				Cible le dossier racine de l'utilisateur.
				\item[-> \textbf{\textcolor{gray}{MegaAssets.Path.USER\_DESKTOP} ou \textcolor{blue}{4}}:] 
				Cible le bureau du système d'exploitation.
				\item[-> \textbf{\textcolor{gray}{MegaAssets.Path.USER\_PICTURES} ou \textcolor{blue}{5}}:] 
				Cible le dossier \textcolor{gray}{\textit{Images}} du système \\d'exploitation.
				\item[-> \textbf{\textcolor{gray}{MegaAssets.Path.USER\_MUSIC} ou \textcolor{blue}{6}}:] 
				Cible le dossier \textcolor{gray}{\textit{Musiques}} du système \\d'exploitation.
				\item[-> \textbf{\textcolor{gray}{MegaAssets.Path.USER\_VIDEOS} ou \textcolor{blue}{7}}:] 
				Cible le dossier \textcolor{gray}{\textit{Vidéos}} du système d'exploitation.
				\item[-> \textbf{\textcolor{gray}{MegaAssets.Path.USER\_DOCUMENTS} ou \textcolor{blue}{8}}:] 
				Cible le dossier \textcolor{gray}{\textit{Documents}} du système \\d'exploitation.
				\item[-> \textbf{\textcolor{gray}{MegaAssets.Path.USER\_DOWNLOADS} ou \textcolor{blue}{9}}:] 
				Cible le dossier \textcolor{gray}{\textit{Téléchargements}} du système \\d'exploitation.\\
			\end{itemize}
		\end{itemize}
	\end{description}
	% Void pixels_adjustment () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{pixels\_adjustment} ()]: Surveille les changements 
		de taille de fenêtre et les poignées pour mettre à l'échelle de l'écran du jeu avec un nombre entier 
		exact, des multiples d'une résolution de base en mémoire. Utile pour les jeu de pixélisation 2D.\\
	\end{description}
	% Static void draw_line_3d () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{draw\_line\_3d} (data, object, live = -1.0, 
		delay = 0.0)]: Déssine une ligne en 3d à partir des différentes données fournit.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Dictionary} data}:] Contient les différentes 
			configurations sur le trâcage et le comportement de la ligne. Le dictionaire supporte les clés 
			suivantes:
			\begin{itemize}
				\item[>> \textbf{\textcolor{darkgreen}{NodePath | String} parent}:] A ligne à trâcée sera
				l'enfant de quel parent ? Si la valeur \\précisée est invalide ou s'il n'y a aucune valeur,
				la valeur se trouvant dans le paramètre \textit{\textcolor{gray}{object}} sera utiliser.\\
				\item[>> \textbf{\textcolor{darkgreen}{Variant} points}:] Contient les coordonnées des 
				différents points sur qui définisseront la \\trajectoire que prendra la ligne à trâcée.
				Notez que vous avez la possibilité de donner un l'instance d'un noeud de type
				\href{https://docs.godotengine.org/en/stable/classes/class_raycast.html}
				{\textit{\textcolor{darkgreen}{RayCast}}}.\\
				\item[>> \textbf{\textcolor{darkgreen}{String} id}:] Contient le nom de la ligne à trâcée.
				Si l'identifiant n'a pas été précisé, \textcolor{gray}{\\"LineRenderer"} est attribué par
				défaut.\\
				\item[>> \textbf{\textcolor{red}{int} mesh = \textcolor{blue}{4}}:] Quelle mesh utilisée 
				pour trâcer la ligne ? Notez que les valeurs possibles sont celles de Godot.\\
				\item[>> \textbf{\textcolor{red}{int} freeze = \textcolor{blue}{0}}:] Quel axe bloqué au
				cours du déssin ? Les valeurs possibles sont:
				\begin{itemize}
					\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.NONE} ou \textcolor{blue}{0}}:] Aucun 
					blockage.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.X} ou \textcolor{blue}{1}}:] Blockage 
					de l'axe des absisses.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.Y} ou \textcolor{blue}{2}}:] Blockage 
					de l'axe des ordonnés.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.Z} ou \textcolor{blue}{3}}:] Bockage 
					de l'axe des côtes.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XY} ou \textcolor{blue}{7}}:] Bockage 
					des axes x et y.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XZ} ou \textcolor{blue}{8}}:] Bockage 
					des axes x et z.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.YZ} ou \textcolor{blue}{9}}:] Bockage 
					des axes y et z.
					\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XYZ} ou \textcolor{blue}{13}}:]
					Bockage des axes x, y et z.\\
				\end{itemize}
				\item[>> \textbf{\textcolor{darkgreen}{Color | ShaderMaterial | SpatialMaterial} skin}:]
				Voulez-vous donner un teint à votre ligne ?\\
				\item[>> \textbf{\textcolor{red}{bool} visible = \textcolor{red}{true}}:] Contrôle la
				visibilité de la ligne.\\
				\item[>> \textbf{\textcolor{red}{float | int} | \textcolor{darkgreen}{Vector2} width = 
				0.004}:] Quelle est l'épaisseur de la ligne ?\\
				\item[>> \textbf{\textcolor{red}{float | int} | \textcolor{darkgreen}{Vector2} smooth = 
				5.0}:] Quel est l'arrondissement des coins et casquettes ?\\
				\item[>> \textbf{\textcolor{red}{bool} skinscale = \textcolor{red}{false}}:] Devons-nous
				augmenter l'échelle d'agrandissement du teint chargé actuellement sur la ligne ?\\
				\item[>> \textbf{\textcolor{darkgreen}{Dictionary | Array} actions}:] Contient le(s) 
				action(s) à éffectuée(s) au cours du déssin de la ligne. L'utilisation de ce paramètre est 
				déjà décrite au niveau des bases du framework. Précisement le sujet portant sur
				l'utilisation de la propriété \textcolor{gray}{EventsBindings} (la section des actions liées 
				à un événement).\\
				\item[>> \textbf{\textcolor{darkgreen}{Dictionary} oncolliding}:] Appelé lorsque le raycast
				référé détecte un objet portant un \\collisionneur. N'utilisez cette clé que si vous donnez
				au niveau de la clé \textit{\textcolor{gray}{points}}, un raycast.\\
				\item[>> \textbf{\textcolor{darkgreen}{NodePath | String | PoolStringArray} impact}:] Quels 
				est/sont le(s) chemin(s) de(s) objet(s) à mettre à la position du point d'impact donné par 
				un raycast ? Vous avez également la \\possibilité de donner de(s) chemin(s) pointant vers 
				de(s) objet(s) préfabriqué(s). N'utilisez cette clé qu'a l'intérieur de la clé
				\textit{\textcolor{gray}{oncolliding}}.\\
				\item[>> \textbf{\textcolor{red}{bool} destroy = \textcolor{red}{true}}:] Devons-nous 
				détruire le(s) objet(s) préfabriqué(s) importé(s) \\lorsqu'on ne détecte aucun objet ?\\
			\end{itemize}
			Notez que vous avez la possibilité d'utiliser l'un des identifiants d'un objet (le nom, le
			groupe et le type de classe appartenant à l'objet détecté par un raycast) pour changer le
			comportement de la ligne.
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer 
			les différentes opérations ?
			\item[>> \textbf{\textcolor{red}{float} live}:] Quel est le temps de vie de la ligne après sa
			création.
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant le trâcement de la 
			ligne ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called every frame. "delta" is the elapsed time since the previous frame.
		func _process (delta):
			# Lets make a laser.
			MegaAssets.draw_line_3d (Dictionary ({
				# If nothing is detected.
				points = "./RayCast",
				parent = '.',
				destroy = true,
				mesh = Mesh.PRIMITIVE_TRIANGLES,
				freeze = MegaAssets.Axis.NONE,
				skin = Color.green,
				id = "RedLaser",
				visible = true,
				actions = {
					source = '.',
					action = "is_running",
					value = false
				}
				# If you detect any physic body or area.
				oncolliding = {
					smooth = "10.0",
					skin = self.get_node ("../ImmediateGeometry").material_override,
					actions = {
						source = '.',
						action = "is_running",
						value = true
					},
					impact = "res://prefabs/cube.tscn",
					width = 0.05,
					# If you found a physic body or area named "StaticBody6".
					StaticBody6 = {
						width = 0.004,
						skin = Color.blue
					}
				},
			}), self);
	\end{lstlisting}
	% Static void debug_line_3d () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{debug\_line\_3d} (show, id, pts, parent,
		color, fze = 0, mesh = 3, delay = 0.0)]: \\Déssine une ligne à partir des différents points donnés.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{bool} show}:] Devons-nous afficher la line ainsi formée ?
			\item[>> \textbf{\textcolor{darkgreen}{String} id}:] Contient le nom de la future ligne à
			trâcée.
			\item[>> \textbf{\textcolor{darkgreen}{Variant} pts}:] Quels sont les différents points à 
			matérialisés ?
			\item[>> \textbf{\textcolor{darkgreen}{Spatial} parent}:] Où devons-nous trâcer la ligne ?
			\item[>> \textbf{\textcolor{darkgreen}{Color} color}:] Contient la couleur de la ligne à trâcée.
			Par défaut, celle-ci est noire.
			\item[>> \textbf{\textcolor{red}{int} fze}:] Quel axe bloqué au cours du déssin ? Les valeurs 
			possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.NONE} ou \textcolor{blue}{0}}:] Aucun 
				blockage.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.X} ou \textcolor{blue}{1}}:] Blockage de
				l'axe des absisses.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.Y} ou \textcolor{blue}{2}}:] Blockage de
				l'axe des ordonnés.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.Z} ou \textcolor{blue}{3}}:] Bockage de
				l'axe des côtes.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XY} ou \textcolor{blue}{7}}:] Bockage des
				axes x et y.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XZ} ou \textcolor{blue}{8}}:] Bockage des
				axes x et z.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.YZ} ou \textcolor{blue}{9}}:] Bockage des
				axes y et z.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XYZ} ou \textcolor{blue}{13}}:] Bockage
				des axes x, y et z.
			\end{itemize}
			\item[>> \textbf{\textcolor{red}{int} mesh}:] Quelle mesh utilisée pour trâcer la ligne ? Notez
			que les valeurs possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{Mesh.PRIMITIVE\_LINES} ou \textcolor{blue}{1}}:] Rendre 
				le tableau sous forme de lignes (tous les deux \\sommets, une ligne est créée).
				\item [-> \textbf{\textcolor{gray}{Mesh.PRIMITIVE\_LINE\_STRIP} ou \textcolor{blue}{2}}:] 
				Rendre le tableau sous forme de bande de ligne.
				\item [-> \textbf{\textcolor{gray}{Mesh.PRIMITIVE\_LINE\_LOOP} ou \textcolor{blue}{3}}:] 
				Rendre le tableau sous forme de boucle de ligne (comme une bande de ligne, mais fermée).
			\end{itemize}
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant la matérialisation 
			des points donnés ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called every frame. "delta" is the elapsed time since the previous frame.
		func _process (delta):
			# Let's debug an AI navigation path.
			MegaAssets.debug_line_3d (true, "NavigationPath",
				nav.get_simple_path (self.translation, target.translation),
				self.get_parent (), Color.cyan, MegaAssets.Axis.Y
			);
	\end{lstlisting}
	% Static void debug_ray_3d () method description.
	\begin{description}
		\item [+ \textcolor{red}{static void} \textcolor{blue}{debug\_ray\_3d} (show, id, start, end, 
		parent, color, fze = 0, delay = 0.0)]: \\Déssine un rayon à partir des différents points donnés.
		\begin{itemize}
			\item[>> \textbf{\textcolor{red}{bool} show}:] Devons-nous afficher le rayon ainsi formé ?
			\item[>> \textbf{\textcolor{darkgreen}{String} id}:] Contient le nom du future rayon à trâcée.
			\item[>> \textbf{\textcolor{darkgreen}{Vector2 | Vector3} start}:] Quelles sont les coordonnées 
			du point de départ ?
			\item[>> \textbf{\textcolor{darkgreen}{Vector2 | Vector3} end}:] Quelles sont les coordonnées du 
			point d'arrivé ?
			\item[>> \textbf{\textcolor{darkgreen}{Spatial} parent}:] Où devons-nous trâcer le rayon ?
			\item[>> \textbf{\textcolor{darkgreen}{Color} color}:] Contient la couleur du rayon à trâcé. Par 
			défaut, celle-ci est noire.
			\item[>> \textbf{\textcolor{red}{int} fze}:] Quel axe bloqué au cours du déssin ? Les valeurs 
			possibles sont:
			\begin{itemize}
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.NONE} ou \textcolor{blue}{0}}:] Aucun 
				blockage.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.X} ou \textcolor{blue}{1}}:] Blockage de
				l'axe des absisses.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.Y} ou \textcolor{blue}{2}}:] Blockage de
				l'axe des ordonnés.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.Z} ou \textcolor{blue}{3}}:] Bockage de
				l'axe des côtes.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XY} ou \textcolor{blue}{7}}:] Bockage des
				axes x et y.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XZ} ou \textcolor{blue}{8}}:] Bockage des
				axes x et z.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.YZ} ou \textcolor{blue}{9}}:] Bockage des
				axes y et z.
				\item [-> \textbf{\textcolor{gray}{MegaAssets.Axis.XYZ} ou \textcolor{blue}{13}}:] Bockage
				des axes x, y et z.
			\end{itemize}
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant la matérialisation 
			des points donnés ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called every frame. "delta" is the elapsed time since the previous frame.
		func _process (delta):
			# Let's debug a raycast path.
			MegaAssets.debug_ray_3d (true, "RayPath", Vector3.ZERO,
				self.get_node ("RayCast").cast_to, self, Color.green, MegaAssets.Axis.NONE
			);
	\end{lstlisting}
	% Static bool is_number () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_number} (input):] L'entrée précisée est-
		elle un nombre (entier ou réel) ?
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient une entrée.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			print (MegaAssets.is_number (5)); # Return true
			print (MegaAssets.is_number (-48.036)); # Return true
			print (MegaAssets.is_number ("Kiss me !")); # Return false
			print (MegaAssets.is_number ("03.896e-7")); # Return true
			print (MegaAssets.is_number ("7")); # Return true
	\end{lstlisting}
	% Static bool is_vector () method description.
	\begin{description}
		\item [+ \textcolor{red}{static bool} \textcolor{blue}{is\_vector} (input):] L'entrée donnée est-
		elle un vecteur (2d ou 3d) ?
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient une entrée.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			print (MegaAssets.is_vector (Vector2.DOWN)); # Return true
			print (MegaAssets.is_vector (Vector3.UP)); # Return true
			print (MegaAssets.is_vector (56.01255)); # Return false
			print (MegaAssets.is_vector ("(03.896e+44.25, -32.14)")); # Return true
			print (MegaAssets.is_vector ("(7, -1, 0.25)")); # Return true
			print (MegaAssets.is_vector ([2.25, -4.256])); # Return true
			print (MegaAssets.is_vector ([-2.5, 9.42e-2, 0])); # Return true
			print (MegaAssets.is_vector ([-7.75, 10.5, 0.0325, -1.014])); # Return false
			print (MegaAssets.is_vector ("[4.69, 8.512]")); # Return true
			print (MegaAssets.is_vector ("[1, 23.93, -0.289]")); # Return true
	\end{lstlisting}
	% Static Variant any_to_vector2 () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{any\_to\_vector2} 
		(input)]: Converti une entrée donnée en un vecteur deux \\dimension. Notez que si l'entrée précisée
		ne respecte pas les exigences d'un vecteur 2d, vous aurez une valeur nulle.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient une entrée.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			print (MegaAssets.any_to_vector2 (Vector2.DOWN)); # Return (0, 1)
			print (MegaAssets.any_to_vector2 (Vector3.UP)); # Return (0, 1)
			print (MegaAssets.any_to_vector2 (56.01255)); # Return Null
			print (MegaAssets.any_to_vector2 ("(03.896e+44.25, -32)")); # Return (inf, -32)
			print (MegaAssets.any_to_vector2 ("(7, -1, 0.25)")); # Return (7, -1)
			print (MegaAssets.any_to_vector2 ([2.25, -4.256])); # Return (2.25, -4.256)
			print (MegaAssets.any_to_vector2 ([-2.5, 9.42e-2, 0])); # Return (-2.5, 0.0942)
			print (MegaAssets.any_to_vector2 ([-7.75, 10.5, 0.0325, -1.014])); # Return Null
			print (MegaAssets.any_to_vector2 ("[4.69, 8.512]")); # Return (4.69, 8.512)
			print (MegaAssets.any_to_vector2 ("[1, 23.93, -0.289]")); # Return (1, 23.93)
	\end{lstlisting}
	% Static Variant any_to_vector3 () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}{any\_to\_vector3} 
		(input)]: Converti une entrée donnée en un vecteur trois \\dimension. Notez que si l'entrée précisée 
		ne respecte pas les exigences d'un vecteur 3d, vous aurez une valeur nulle.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Variant} input}:] Contient une entrée.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			print (MegaAssets.any_to_vector3 (Vector2.DOWN)); # Return (0, 1, 0)
			print (MegaAssets.any_to_vector3 (Vector3.UP)); # Return (0, 1, 0)
			print (MegaAssets.any_to_vector3 (56.01255)); # Return Null
			print (MegaAssets.any_to_vector3 ("(03.896e+44.25, -32)")); # Return (inf, -32, 0)
			print (MegaAssets.any_to_vector3 ("(7, -1, 0.25)")); # Return (7, -1, 0.25)
			print (MegaAssets.any_to_vector3 ([2.25, -4.256])); # Return (2.25, -4.256, 0)
			print (MegaAssets.any_to_vector3 ([-2.5, 9.42e-2, 0])); # Return (-2.5, 0.0942, 0)
			print (MegaAssets.any_to_vector3 ([-7.75, 10.5, 0.0325, -1.014])); # Return Null
			print (MegaAssets.any_to_vector3 ("[4.69, 8.512]")); # Return (4.69, 8.512, 0)
			print (MegaAssets.any_to_vector3 ("[1, 23.93, -0.289]")); # Return (1, 23.93, 0.289)
	\end{lstlisting}
	% Static Variant split_vector3_path () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Variant} \textcolor{blue}
		{split\_vector3\_path} (points, count)]: Subdivise un chemin représenté par plusieurs points de 
		l'espace en de sous petit points de l'espace dont chacun appartient à la trajectoire \\représentée
		par les points originaux.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Array | PoolVector2Array | PoolVector3Array} points}:]
			Contient l'ensemble des points \\représentant un chemin quelconque.
			\item [>> \textbf{\textcolor{red}{int} count}:] Les différents segments formés les points 
			originaux seront subdivisés en combien de sous segment ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			print (MegaAssets.split_vector3_path ([Vector3.UP, Vector3.DOWN], 3));
				# Return [(0, 1, 0), (0, -0.333333, 0), (0, -1.666667, 0), (0, -1, 0)]
	\end{lstlisting}
	% Static PoolByteArray rand_bytes () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{PoolByteArray} \textcolor{blue}
		{rand\_bytes} (size)]: Génère un tableau d'octets en fonction d'une taille.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} size}:] Contient la taille du tableau à généré.\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready (): print (Array (MegaAssets.rand_bytes (4))); # Return [245, 235, 59, 232]
	\end{lstlisting}
	% Static String str_replace () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{str\_replace} 
		(string, what, to, start = -1, end = -1)]: Remplace un ou plusieurs \\caractère(s) par un ou
		plusieurs autre(s) caractère(s).
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient une chaîne de caractères.
			\item [>> \textbf{\textcolor{darkgreen}{String | PoolStringArray} what}:] Quel(s) est/sont le(s) 
			caractère(s) qui sera/ront remplacé(s) ?
			\item [>> \textbf{\textcolor{darkgreen}{String | PoolStringArray} to}:] Quel(s) est/sont le(s) 
			caractère(s) qui prendera/ont la place de(s) caractère(s) désigné(s) ?
			\item [>> \textbf{\textcolor{red}{int} | \textcolor{darkgreen}{String} start}:] A partir de quel
			caractère ou position les remplacements vont s'éffectués ?
			\item [>> \textbf{\textcolor{red}{int} | \textcolor{darkgreen}{String} end}:] A quel caractère 
			ou position les remplacements vont s'arrêtés ?\\
		\end{itemize}
	\end{description}
	\newpage \textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			# Multiple replacement test.
			print (MegaAssets.str_replace ("Ooops ! Sorry", ['!', 'O', 'y'], ['?', 'o']));
				# Return "ooops ? Sorro"
	\end{lstlisting}
	% Static String str_lrstrip () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{String} \textcolor{blue}{str\_lrstrip} 
		(string, what\_left = '', what\_right = '')]: Supprime les caractères situés à gauche et à droite
		dans une chaîne de caractères.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} string}:] Contient une chaîne de caractères.
			\item [>> \textbf{\textcolor{darkgreen}{String | PoolStringArray} what\_left}:] Quel(s) est/sont 
			le(s) caractère(s) à supprimé(s) à gauche de la chaîne de caractères donnée ?
			\item [>> \textbf{\textcolor{darkgreen}{String | PoolStringArray} what\_right}:] Quel(s) est/
			sont le(s) caractère(s) à supprimé(s) à droite de la chaîne de caractères donnée ?\\
		\end{itemize}
	\end{description}
	\textbf{Code: GDScript}
	\begin{lstlisting}
		# Called after game is ready.
		func _ready ():
			# Mutliple removing test.
			print (MegaAssets.str_lrstrip ("\n  Ooops ! Sorry  \t", ["\n", ' '], ["\t", ' ']));
				# Return "Ooop ! Sorry"
	\end{lstlisting}
	% Static int get_real_image_format () method description.
	\begin{description}
		\item [+ \textcolor{red}{static int} \textcolor{blue}{get\_real\_image\_format} (option)]: Renvoie
		la position corresponde à l'option donnée au sein de l'énumération \textit{\textcolor{gray}{Format}}
		de la classe 
		\href{https://docs.godotengine.org/en/stable/classes/class_image.html#enum-image-format}
		{\textit{\textcolor{darkgreen}{Image}}} de Godot.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} option}:] Contient la position d'une option définit au
			sein de l'énumération \\\textcolor{darkgreen}{MegaAssets}.\textcolor{gray}{ImageFormat}.\\
		\end{itemize}
	\end{description}
	% Static int get_real_image_compression () method description.
	\begin{description}
		\item [+ \textcolor{red}{static int} \textcolor{blue}{get\_real\_image\_compression} (option)]: 
		Renvoie	la position corresponde à l'option \\donnée au sein de l'énumération 
		\textit{\textcolor{gray}{CompressMode}} de la classe 
		\href{https://docs.godotengine.org/en/stable/classes/class_image.html#enum-image-compressmode}
		{\textit{\textcolor{darkgreen}{Image}}} de Godot.
		\begin{itemize}
			\item [>> \textbf{\textcolor{red}{int} option}:] Contient la position d'une option définit au
			sein de l'énumération \\\textcolor{darkgreen}{MegaAssets}.\textcolor{gray}{ImageCompression}.\\
		\end{itemize}
	\end{description}
	% Static Array get_screen_shot_data () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Array} \textcolor{blue}
		{get\_screen\_shot\_data} (object, data = \{\}):] Génère une capture de l'écran du jeu et renvoie 
		ses données.
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considérer pour 
			éffectuer les différentes opérations ?
			\item [>> \textbf{\textcolor{darkgreen}{Dictionary} data}:] Contient les différentes
			configurations à effectuées sur la capture, une fois \\générée. Pour avoir plus d'informations,
			consulter la documentation sur la fonction \textit{\textcolor{blue}{\\get\_screen\_shot ()}}.\\
		\end{itemize}
	\end{description}
	% Static Array load_csv_file () method description.
	\begin{description}
		\item [+ \textcolor{red}{static} \textcolor{darkgreen}{Array} \textcolor{blue}{load\_csv\_file}
		(path, separator = ','):] Charge le contenu d'un fichier d'extension \\(.csv).
		\begin{itemize}
			\item [>> \textbf{\textcolor{darkgreen}{String} path}:] Contient le chemin pointant vers le
			fichier csv à chargé.
			\item [>> \textbf{\textcolor{darkgreen}{String} separator}:] Quelle chaîne devons-nous utiliser
			pour distinguer les différentes données du fichier csv ?\\
		\end{itemize}
	\end{description}
	% Void open_doc () method description.
	\begin{description}
		\item [+ \textcolor{red}{void} \textcolor{blue}{open\_doc} (object, feature = '', delay = 0.0):]
		Ouvre la documentation associée à la classe en question.
		\begin{itemize}
			\item[>> \textbf{\textcolor{darkgreen}{Node} object}:] Quel noeud sera considéré pour éffectuer
			les différentes opérations ?
			\item[>> \textbf{\textcolor{darkgreen}{String} feature}:] La documentation ciblera quelle
			fonctionnalité de la classe ?
			\item[>> \textbf{\textcolor{red}{float} delay}:] Quel est le temps mort avant l'ouverture de la
			documentation ?
		\end{itemize}
	\end{description}
\end{document}